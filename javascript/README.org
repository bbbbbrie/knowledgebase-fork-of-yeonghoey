#+TITLE: Javascript

* Table of Contents :TOC_3_gh:
- [[#syntax][Syntax]]
  - [[#for][for]]
  - [[#function][function]]
  - [[#switch][switch]]
- [[#types][Types]]
  - [[#object][Object]]
  - [[#symbol][Symbol]]
- [[#reference][Reference]]
  - [[#global-functions][Global functions]]
    - [[#alert-prompt-confirm][alert, prompt, confirm]]
    - [[#encodeuri-encodeuricomponent-decodeuri-decodeuricomponent][encodeURI, encodeURIComponent, decodeURI, decodeURIComponent]]
  - [[#string][String]]
  - [[#string-literals][String Literals]]
- [[#topics][Topics]]
  - [[#use-strict]['use strict';]]
  - [[#let-const-var][let, const, var]]
  - [[#type-conversions][Type Conversions]]
  - [[#comparisons][Comparisons]]
  - [[#style-guides][Style Guides]]
  - [[#garbage-collection][Garbage collection]]
- [[#how-to][How-to]]
  - [[#parse-uri][Parse URI]]
  - [[#put-script][Put <script>]]
- [[#links][Links]]

* Syntax
- https://javascript.info/javascript-specials

** for
- https://javascript.info/while-for

#+BEGIN_SRC javascript
  outer: for (let i = 0; i < 3; i++) {

    for (let j = 0; j < 3; j++) {

      let input = prompt(`Value at coords (${i},${j})`, '');

      // if an empty string or canceled, then break out of both loops
      if (!input) break outer; // (*)

      // do something with the value...
    }
  }
  alert('Done!');
#+END_SRC

** function
- https://javascript.info/function-expressions-arrows

#+BEGIN_SRC javascript
  function sayHi() {
    alert( "Hello" );
  }

  let sayHi = function() {
    alert( "Hello" );
  };
#+END_SRC

#+BEGIN_SRC javascript
  let age = 16; // take 16 as an example

  if (age < 18) {
    welcome();               // \   (runs)
                             //  |
    function welcome() {     //  |
      alert("Hello!");       //  |  Function Declaration is available
    }                        //  |  everywhere in the block where it's declared
                             //  |
    welcome();               // /   (runs)

  } else {

    function welcome() {     //  for age = 16, this "welcome" is never created
      alert("Greetings!");
    }
  }

  // Here we're out of figure brackets,
  // so we can not see Function Declarations made inside of them.

  welcome(); // Error: welcome is not defined
#+END_SRC

- By put ~let welcome;~ before the ~if~, we can access ~welcome~ at last.

#+BEGIN_SRC javascript
  let func = (arg1, arg2, ...argN) => expression

  let double = n => n * 2; // paran can be omitted

  let sum = (a, b) => {  // the figure bracket opens a multiline function
    let result = a + b;
    return result; // if we use figure brackets, use return to get results
  };
#+END_SRC

** switch
- https://javascript.info/switch

#+BEGIN_SRC javascript
  switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
      [break]

  case 'value2':  // if (x === 'value2')
    ...
      [break]

  default:
    ...
      [break]
  }
#+END_SRC
- The value of x is checked for a *strict equality*

* Types
** Object
- https://javascript.info/object

#+BEGIN_SRC javascript
  let user = new Object(); // "object constructor" syntax

  let user = {
    name: "John",
    age: 30,
    "likes birds": true  // multiword property name must be quoted
  };

  alert( user.name ); // John
  alert( user.age ); // 30
  delete user.age;

  // multiword
  user["likes birds"] = true;
  alert(user["likes birds"]); // true

  let fruit = "apple";
  let bag = {
    [fruit]: 5, // the name of the property is taken from the variable fruit
  };
  alert(bag.apple);

  function makeUser(name, age) {
    return {
      name, // same as name: name
      age   // same as age: age
      // ...
    };
  }

  let user = { name: "John", age: 30 };

  alert("age" in user);                     // true, user.age exists
  alert("blabla" in user);                  // false, user.blabla doesn't exist
  alert(user.noSuchProperty === undefined); // true means "no such property"

  for (key in object) {
    // executes the body for each key among object properties
  }

  let user = { name: "John" };

  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };

  // copies all properties from permissions1 and permissions2 into user
  Object.assign(user, permissions1, permissions2);

  // now user = { name: "John", canView: true, canEdit: true }

  let user = {
    name: "John",
    age: 30
  };

  let clone = Object.assign({}, user);
#+END_SRC

** Symbol
- https://javascript.info/symbol

#+BEGIN_SRC javascript
  // “Symbol” value represents a unique identifier.
  // The first argument is a description("id", in this case), useful for debugging
  let id1 = Symbol("id");
  let id2 = Symbol("id");

  alert(id1 == id2); // false

  let user = { name: "John" };
  // Work as a hidden property
  let id = Symbol("id");

  user[id] = "ID Value";
  alert( user[id] ); // we can access the data using the symbol as the key

  let id = Symbol("id");
  let user = {
    name: "John",
    age: 30,
    [id]: 123
  };

  for (let key in user) alert(key); // name, age (no symbols)

  // the direct access by the symbol works
  alert( "Direct: " + user[id] );

  // read from the global registry
  let id = Symbol.for("id"); // if the symbol did not exist, it is created

  // read it again
  let idAgain = Symbol.for("id");

  // the same symbol
  alert( id === idAgain ); // true

  let sym = Symbol.for("name");
  let sym2 = Symbol.for("id");

  // get name from symbol
  alert( Symbol.keyFor(sym) ); // name
  alert( Symbol.keyFor(sym2) ); // id
#+END_SRC

#+BEGIN_SRC javascript
  // we can omit "function" and just write sayHi().
  let user = {
    name: "John",
    age: 30,

    sayHi() {
      alert(this.name);
    }

  };

  user.sayHi(); // John

  function sayHi() {
    alert(this);
  }

  sayHi(); // undefined

#+END_SRC

#+BEGIN_QUOTE
In this case this is undefined in strict mode. If we try to access this.name, there will be an error.
In non-strict mode (if one forgets use strict) the value of this in such case will be the global object (window in a browser, we’ll get to it later). This is a historical behavior that "use strict" fixes.
Please note that usually a call of a function that uses this without an object is not normal, but rather a programming mistake. If a function has this, then it is usually meant to be called in the context of an object
#+END_QUOTE

#+BEGIN_SRC javascript
  let user = {
    name: "John",
    hi() { alert(this.name); }
  }

  // split getting and calling the method in two lines
  let hi = user.hi;
  hi(); // Error, because this is undefined
#+END_SRC

To make ~user.hi()~ calls work, JavaScript uses a trick – the dot '.' returns not a function, but a value of the special Reference Type.
The value of Reference Type is a three-value combination ~(base, name, strict)~

Any other operation like assignment ~hi = user.hi~ discards the reference type as a whole.

So, as the result, the value of this is only passed the right way if the function is called directly using a dot ~obj.method()~ or square brackets ~obj[method]()~ syntax (they do the same here).

#+BEGIN_SRC javascript
  let user = {
    firstName: "Ilya",
    sayHi() {
      let arrow = () => alert(this.firstName);
      arrow();
    }
  };

  user.sayHi(); // Ilya
#+END_SRC

#+BEGIN_SRC javascript
  function User(name) {
    this.name = name;
    this.isAdmin = false;
  }

  let user = new User("Jack");

  alert(user.name); // Jack
  alert(user.isAdmin); // false

  // 1. A new empty object is created and assigned to this.
  // 2. The function body executes. Usually it modifies this, adds new properties to it.
  // 3. The value of this is returned.


  function User(name) {
    if (!new.target) { // if you run me without new
      return new User(name); // ...I will add new for you
    }

    this.name = name;
  }

  let john = User("John"); // redirects call to new User
  alert(john.name); // John
#+END_SRC
* Reference
** Global functions
*** alert, prompt, confirm
- https://javascript.info/alert-prompt-confirm

#+BEGIN_SRC javascript
  alert("Hello");

  let age = prompt('How old are you?', 100); // always supply a 'default'
  alert(`You are ${age} years old!`);

  let isBoss = confirm("Are you the boss?");
  alert( isBoss ); // true if OK is pressed
#+END_SRC

*** encodeURI, encodeURIComponent, decodeURI, decodeURIComponent
- https://stackoverflow.com/questions/75980/when-are-you-supposed-to-use-escape-instead-of-encodeuri-encodeuricomponent
- ~escape~, ~unescape~ are deprecated
- The difference between ~-URI~ and ~-URIComponent~ is following:
[[file:_img/screenshot_2017-06-03_21-15-23.png]]

** String
- https://www.w3schools.com/jsref/jsref_obj_string.asp

** String Literals
- https://stackoverflow.com/questions/242813/when-to-use-double-or-single-quotes-in-javascript 
- Single and double quotes are literally same (except escaping)
- It seems that *single quotes are preferred* in the most famous libraries.
- Backticks are used for string interpolation.

#+BEGIN_SRC javascript
  let name = "John";

  // embed a variable
  alert( `Hello, ${name}!` ); // Hello, John!

  // embed an expression
  alert( `the result is ${1 + 2}` ); // the result is 3
#+END_SRC

* Topics
** 'use strict';
- https://javascript.info/strict-mode

Strict mode is declared by adding ~'use strict';~ to the beginning of a script or a function.
Always use it. It's a kind of *modern mode*

** let, const, var
- https://javascript.info/var

- ~let~ and ~const~ behave exactly the same way in terms of Lexical Environments.

- ~var~ has no block scope ::
#+BEGIN_SRC javascript
  if (true) {
    var test = true; // use "var" instead of "let"
  }

  alert(test); // true, the variable lives after if
#+END_SRC

- ~var~ are processed at the function start ::
#+BEGIN_SRC javascript
  function sayHi() {
    phrase = "Hello";

    alert(phrase);

    var phrase;
  }
#+END_SRC

** Type Conversions
- https://javascript.info/type-conversions

#+BEGIN_SRC javascript
  alert( Number("   123   ") ); // 123
  alert( Number("123z") );      // NaN (error reading a number at "z")
  alert( Number(true) );        // 1
  alert( Number(false) );       // 0
  alert( Boolean(1) );          // true
  alert( Boolean(0) );          // false
  alert( Boolean("hello") );    // true
  alert( Boolean("") );         // false
  alert( 1 + '2' );             // '12' (string to the right)
  alert( '1' + 2 );             // '12' (string to the left)
#+END_SRC

** Comparisons
#+BEGIN_SRC javascript
  alert( '2' > 1 );            // true, string '2' becomes a number 2
  alert( '01' == 1 );          // true, string '01' becomes a number 1
  alert( true == 1 );          // true
  alert( false == 0 );         // true
  alert( '' == false );        // true

  alert( 0 == false );         // true
  alert( 0 === false );        // false, because the types are different

  alert( null > 0 );           // false
  alert( null == 0 );          // false, null special rule applied
  alert( null >= 0 );          // true,  null is converted to 0

  alert( null == undefined );  // true
  alert( null === undefined ); // false
#+END_SRC

- Use ~===~ much more often than ~==~.
- ~null~ and ~undefined~ equal ~==~ each other and do not equal any other value.
- Don’t use comparisons ~>=~ ~>~ ~<~ ~<=~ with a variable which may be ~null~ / ~undefined~

** Style Guides
- https://javascript.info/coding-style
- https://github.com/rwaldron/idiomatic.js
- https://google.github.io/styleguide/javascriptguide.xml

** Garbage collection
- https://javascript.info/garbage-collection
- http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection


- Mark and sweep
- Generational collection
- Incremental collection
- Idle-time collection


* How-to
** Parse URI
- https://gist.github.com/jlong/2428561

#+BEGIN_SRC javascript
  var parser = document.createElement('a');
  parser.href = "http://example.com:3000/pathname/?search=test#hash";

  parser.protocol; // => "http:"
  parser.hostname; // => "example.com"
  parser.port;     // => "3000"
  parser.pathname; // => "/pathname/"
  parser.search;   // => "?search=test"
  parser.hash;     // => "#hash"
  parser.host;     // => "example.com:3000"
#+END_SRC

** Put <script>
- https://javascript.info/hello-world
- http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html


- As a rule, only the simplest scripts are put into HTML. 
- The benefit of a separate file is that the browser will download it and then store in its cache.
- If ~src~ is set, the script content is ignored.
- The ~type~ and ~language~ attributes are not required.

#+BEGIN_SRC html
  <script src="path/to/script.js"></script>
#+END_SRC


[[file:_img/screenshot_2018-03-02_03-27-42.png]]

- If the script is modular and does not rely on any scripts then use ~async~.
- If the script relies upon or is relied upon by another script then use ~defer~.
- If the script is small and is relied upon by an ~async~ script then use an ~inline script~ with no attributes placed above the ~async~ scripts.

* Links
- https://javascript.info/ 

