#+TITLE: Shell

* Table of Contents                                                :TOC_3_gh:
- [[#reference][Reference]]
  - [[#builtins][Builtins]]
    - [[#export][export]]
    - [[#set][set]]
  - [[#commands][Commands]]
    - [[#curl][curl]]
    - [[#date][date]]
    - [[#grep][grep]]
    - [[#jq][jq]]
    - [[#sort][sort]]
    - [[#tar][tar]]
    - [[#tee][tee]]
    - [[#watch][watch]]
    - [[#xargs][xargs]]
  - [[#keywords][Keywords]]
    - [[#-][$@, $*]]
    - [[#array][array]]
    - [[#case][case]]
    - [[#for][for]]
    - [[#function][function]]
    - [[#if][if]]
  - [[#syntax][Syntax]]
    - [[#arithmetic-expansion][Arithmetic Expansion]]
    - [[#brace-expansion][Brace Expansion]]
    - [[#escaping-quotes][Escaping quotes]]
    - [[#here-document][Here document]]
    - [[#history-expansion][History Expansion]]
    - [[#process-substitution][Process Substitution]]
    - [[#redirection][Redirection]]
    - [[#shebang][Shebang]]
    - [[#shell-parameter-expansion][Shell Parameter Expansion]]
- [[#topics][Topics]]
  - [[#pseudo-terminals][Pseudo Terminals]]
- [[#how-to][How-to]]
  - [[#change-hostname][Change hostname]]
  - [[#empty-the-contents-of-a-file][Empty the contents of a file]]
  - [[#force-exit-code-0-in-spite-of-error][Force exit code 0 in spite of error]]
  - [[#get-the-source-directory][Get the source directory]]
  - [[#glob-dotfiles][Glob dotfiles]]
  - [[#pipe-stderr-and-not-stdout][Pipe stderr, and not stdout?]]
  - [[#prevent-partially-downloaded-scripts-from-executing][Prevent partially downloaded scripts from executing]]
  - [[#prompt-a-user-for-yesno][Prompt a user for yes/no]]
  - [[#run-python-simple-web-server-for-sharing-files][Run python simple web server for sharing files]]
  - [[#temporarily-move-to-a-different-working-directory-via-subshell][Temporarily move to a different working directory via subshell]]
  - [[#trim-a-variable][Trim a variable]]
  - [[#use-command-output-as-a-file][Use command output as a file]]
  - [[#useful-one-liners][Useful One-liners]]
  - [[#wait-until-a-port-available][Wait until a port available]]
- [[#links][Links]]
- [[#staging][Staging]]
  - [[#2017-06-29-thu-shift][<2017-06-29 Thu> shift]]
  - [[#2017-02-09-thu-how-do-i-copy-multiple-files-by-wildcard][<2017-02-09 Thu> How do I copy multiple files by wildcard?]]
  - [[#2017-02-01-wed-crond][<2017-02-01 Wed> cron.d]]
  - [[#2017-02-01-wed-device-naming-on-linux-instances][<2017-02-01 Wed> Device Naming on Linux Instances]]
  - [[#2017-03-01-wed-command-command][<2017-03-01 Wed> command command]]
  - [[#2017-03-01-wed-detect-ostype][<2017-03-01 Wed> Detect ostype]]
  - [[#2017-03-30-thu-trap][<2017-03-30 Thu> trap]]
  - [[#2017-07-02-sun-bash-curly-braces-in-variables][<2017-07-02 Sun> Bash curly braces in variables]]
  - [[#2017-07-03-mon-here-document-to-variables][<2017-07-03 Mon> here-document to variables]]
  - [[#2017-07-03-mon-cat--][<2017-07-03 Mon> "cat -"]]
  - [[#2017-07-03-mon-ifs][<2017-07-03 Mon> IFS?]]
  - [[#2017-07-03-mon-here_strings][<2017-07-03 Mon> HERE_STRINGS]]
  - [[#2017-07-03-mon-wc--l][<2017-07-03 Mon> wc -l]]
  - [[#2017-07-03-mon-source-in-function][<2017-07-03 Mon> source in function]]
  - [[#eval-vs-source][eval vs source]]
  - [[#addpath][addpath]]
  - [[#if-content-exists-multiline-string][if content exists multiline string]]
  - [[#echo-string1string2][echo "${string1#"$string2"}"]]
  - [[#bash-grouping-commands][bash grouping commands]]
  - [[#capturing-multiline-output][capturing multiline output]]
  - [[#bash-source-return][bash source return]]
  - [[#sudo-keep-alive][sudo keep alive]]
  - [[#gnu-locale-categories][GNU locale categories]]
  - [[#set--e-not-exit-in-function][set -e not exit in function]]
  - [[#bash-check-variable-exists][bash check variable exists]]
  - [[#shell-initialization][shell initialization]]
  - [[#check-if-a-program-exists][check if a program exists]]
  - [[#check-if-two-paths-are-equal-in-bash][check if two paths are equal in Bash]]
  - [[#delete-all-broken-symbolic-links-with-a-line][Delete all broken symbolic links with a line]]
  - [[#determine-current-shell][determine current shell]]
  - [[#hash--r][hash -r]]
  - [[#negative-offset-of-shell-parameter-expansion][negative offset of shell parameter expansion]]
  - [[#empty-array-and-][empty array and [@]]]

* Reference
** Builtins
*** export
- https://ss64.com/bash/export.html
- Mark each *name to be passed to child processes* in the environment.
- It doesn't matter whether you set a variable before ~export~ or vice versa.

#+BEGIN_SRC shell
  export [-fn] [-p] [name[=value]]
  # -f   The names refer to shell functions
  #      otherwise the names refer to shell variables
  # -n   no longer mark each name for export
  # -p   Display output in a form that can be reused as input.
#+END_SRC

*** set
- https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html
- https://github.com/jlevy/the-art-of-command-line

#+BEGIN_SRC shell
  set -e # Exit immediately when a command fails
  set -x # Print a trace of simple commands

  set +x # Use + rather than -  to turn off.

  set -- 'foo' 'bar' # set the positional parameters
  echo "$1, $2"      # 'foo, bar'
#+END_SRC

#+BEGIN_SRC shell
  set -euo pipefail
  trap "echo 'error: Script failed: see failed command above'" ERR
#+END_SRC
- ~-e~ for errors
- ~-u~ for preventing unset
- ~-o pipefail~ for errors within pipes

**** set -x for a line
- http://stackoverflow.com/questions/13195655/bash-set-x-without-it-being-printed

#+BEGIN_SRC shell
  set -x
  command
  { set +x; } 2>/dev/null

  # or simply
  ( set -x; command )
#+END_SRC

** Commands
*** curl
- https://ec.haxx.se/usingcurl-returns.html

#+BEGIN_SRC shell
  # return exit code 22 when url not found or
  # HTTP error code being 400 or above
  curl --fail <url>
#+END_SRC

*** date
- https://www.gnu.org/software/coreutils/manual/html_node/Options-for-date.html
- https://www.gnu.org/software/coreutils/manual/html_node/Examples-of-date.html

#+BEGIN_SRC shell
  date -u
  #     └─ --utc
  # Fri Aug 18 06:57:31 UTC 2017

  date -R
  #     └─ --rfc─2822
  # Fri, 18 Aug 2017 15:55:42 +0900

  date '+%Y%m%dT%H%M%S'
  # 20170818T144038

  TZ='America/Los_Angeles' date
  # Fri Aug 18 00:01:11 PDT 2017

  date -d '2days ago'
  #     └─ --date, display time described by STRING, not 'now'
  # Wed Aug 16 16:05:03 KST 2017

  date -d '2days ago' '+%Y%m%dT%H%M%S'
  # 20170816T160622

  date --iso-8601
  # 2017-08-18

  date --iso-8601=seconds
  #                    └─ also can be 'auto', 'hours', 'minutes', 'ns'
  # 2017-08-18T17:12:30+09:00

  date --utc --iso-8601=seconds
  # 2017-08-18T08:12:49+00:00
#+END_SRC

*** grep
- https://www.gnu.org/software/grep/manual/grep.html#Usage

#+BEGIN_SRC shell
  $ tail *.txt
  ==> foo.txt <==
  foo
  FOO

  ==> foobar.txt <==
  foo
  bar
  foobar
#+END_SRC

#+BEGIN_SRC shell
  $ grep foo foo.txt
  foo

  $ grep -i foo foo.txt  # -i, --ignore-case
  foo
  FOO

  $ grep -n foo foobar.txt  # -n, --line-number
  1:foo
  3:foobar

  $ grep -o foo foobar.txt  # -o, --only-matching
  foo
  foo

  $ grep -v foo foobar.txt  # -v, --invert-match
  bar

  $ grep -l foo *  # -l, --files-with-matches
  foo.txt
  foobar.txt

  $ grep -H foo *  # -H, Always print filename headers
  foo.txt:foo
  foobar.txt:foo
  foobar.txt:foobar

  $ grep -r foo .  # -R, -r, --recursive, Prints filename headers by default
  ./foo.txt:foo
  ./foobar.txt:foo
  ./foobar.txt:foobar

  $ grep -rh foo .  # -h, --no-filename
  foo
  foo
  foobar

  $ grep -w foo foobar.txt  # -w, --word-regexp
  foo

  $ grep -C2 bar foobar.txt  # -C[num, --context=num], num=2 by default, See also -A(after), -B(before)
  foo
  bar
  foobar

  $ grep -F foo.* foobar.txt  # -F, --fixed-strings, literal match

  $ grep -q foo foo.txt; echo $?  # -q, --quiet, --silent
  0
  $ grep -q bar foo.txt; echo $?
  1

  $ grep -e '--foo' foo.txt  # -e [pattern], --regexp=pattern, Indicate following argument as regexp explicitly

  $ grep -Z foo foobar.tar.gz; echo $?  # -Z, -z, --decompress, Behave as zgrep
  Binary file foobar.tar.gz matches
  0
  $ grep -Z baz foobar.tar.gz; echo $?
  1
#+END_SRC

*** jq
- https://stedolan.github.io/jq/manual/
- https://jqplay.org/

#+BEGIN_SRC json
  [{"name": "apple", "price": 10}, {"name": "orange", "price": 20}]
#+END_SRC

#+BEGIN_SRC shell
  jq '.[] | select(.["name"] | test("or.*")) | {(.["name"]): .["price"]}'
  #              │                │             │          └─ object construction
  #              │                │             └─ expression keys need to be parenthesized
  #              │                └─ regex match returns boolean
  #              └─ select values where conditional is true
#+END_SRC

#+BEGIN_SRC json
  {"orange": 20}
#+END_SRC

*** sort
- http://ss64.com/bash/sort.html
- http://www.skorks.com/2010/05/sort-files-like-a-master-with-the-linux-sort-command-bash/

#+BEGIN_SRC shell
  sort -nr numbers.txt # descending numeric order
  sort -k3 output.txt  # key3, omitting the first and second fields.
  sort -f names.txt    # ignore case
  sort -s names.txt    # stable sort
  sort -u names.txt    # unique
  sort -t: /etc/passwd # use ':' as the field delimiter
#+END_SRC

#+BEGIN_SRC shell
  # Sort by column2 and then column4, numerically, delimited by '.'
  # while -k2  only specifies starting point is column2
  # -k2,2  specifies both starting, and ending point. which means exact column2.

  $ cat ips.txt | sort -t. -k 2,2n -k 4,4n
  127.0.0.3
  127.0.0.6
  127.0.0.12
  192.168.0.1
  192.168.0.5
  192.168.0.25
#+END_SRC

*** tar
- http://www.tecmint.com/18-tar-command-examples-in-linux/
- http://askubuntu.com/questions/122141/whats-the-difference-between-tar-gz-and-gz-or-tar-7z-and-7z

| flag      | mnemonic         |
|-----------+------------------|
| ~-c~      | create           |
| ~-x~      | extract          |
| ~-t~      | list             |
| ~-v~      | verbose          |
| ~-z~      | gzip             |
| ~-C DIR~  | change directory |
| ~-f FILE~ | target file      |

-----
#+BEGIN_SRC shell
  $ cd /tmp
  $ tree target
#+END_SRC
#+BEGIN_EXAMPLE
  target
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -cvf target1.tar /tmp/target
#+END_SRC
#+BEGIN_EXAMPLE
  tar: Removing leading '/' from member names
  a tmp/target
  a tmp/target/a.txt
  a tmp/target/path
  a tmp/target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -xvf target1.tar
  $ tree tmp
#+END_SRC
#+BEGIN_EXAMPLE
  tmp
  └── target
      ├── a.txt
      └── path
          └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Change directory
  $ tar -C /tmp/target -cvf target2.tar .
#+END_SRC
#+BEGIN_EXAMPLE
  a .
  a ./a.txt
  a ./path
  a ./path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ mkdir out
  $ tar -C out -xvf target2.tar
  $ tree out
#+END_SRC
#+BEGIN_EXAMPLE
  out
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Exclude
  $ tar -cvf target3.tar --exclude a.txt target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
#+BEGIN_SRC shell
  # Compression
  $ tar -cvzf target.tar.gz target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/a.txt
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Don't need any option for extracting compressed tar
  $ tar -xvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  x target/
  x target/a.txt
  x target/path/
  x target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # List
  $ tar -tvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/a.txt
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/path/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Untar a single file
  $ tar -xvf target.tar.gz target/a.txt
#+END_SRC
#+BEGIN_EXAMPLE
  x target/a.txt
#+END_EXAMPLE

*** tee
- https://shapeshed.com/unix-tee/

#+BEGIN_SRC shell
  $ echo 'foo' | tee foo.txt
  foo
  $ cat foo.txt
  foo
#+END_SRC

#+BEGIN_SRC shell
  $ cat foo.txt
  foo
  $ echo 'bar' | tee -a foo.txt  # append
  bar
  $ cat foo.txt
  foo
  bar
#+END_SRC

#+BEGIN_SRC shell
  # Redirecting stdout is not affected by 'sudo'
  $ echo 'foo' >> file
  zsh: permission denied: file

  # 'tee' can be used to work around this
  $ echo "foo" | sudo tee -a file
#+END_SRC

*** watch
#+BEGIN_SRC shell
  watch ls        # run 'ls' every 2 seconds (default)
  watch -d ls     # highlight differences
  watch -n 60 ls  # every 60 seconds
#+END_SRC

*** xargs
- http://www.thegeekstuff.com/2013/12/xargs-examples
- http://www.unixmantra.com/2013/12/xargs-all-in-one-tutorial-guide.html
- https://www.cyberciti.biz/faq/linux-unix-bsd-xargs-construct-argument-lists-utility/

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs echo

  # equivalent to:
  echo 1 2 3 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 1 echo

  # equivalent to:
  echo 1
  echo 2
  echo 3
  echo 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 2 echo

  # equivalent to:
  echo 1 2
  echo 3 4
#+END_SRC

#+BEGIN_SRC shell
  # Specify replace-str
  $ echo 1 2 3 4 | xargs -I {} echo '{} numbers'

  # equivalent to
  echo '1 2 3 4 numbers'
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -p echo   # Prompt
  $ echo 1,2,3,4 | xargs -d, echo  # Set delimiter to ','

  # Use null character as input terminator, useful when input contains white space.
  # For example, 'find -print0' supports this
  $ echo 1 2 3 4 | xargs -0 echo

  # Delete files whose names contain 'conflicted'
  $ find . -name '*conflicted*' -print0 | xargs -0 rm
#+END_SRC

** Keywords
*** $@, $*
- http://stackoverflow.com/questions/12314451/accessing-bash-command-line-args-vs
- https://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters
- Use ~​"$@"​~ for most cases

#+BEGIN_SRC shell
  $ set -- "arg  1" "arg  2" "arg  3"

  $ for word in $*; do echo "$word"; done
  arg
  1
  arg
  2
  arg
  3

  $ for word in $@; do echo "$word"; done
  arg
  1
  arg
  2
  arg
  3

  $ for word in "$*"; do echo "$word"; done
  arg  1 arg  2 arg  3

  $ for word in "$@"; do echo "$word"; done
  arg  1
  arg  2
  arg  3
#+END_SRC

*** array
- https://www.gnu.org/software/bash/manual/bashref.html#Arrays
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html

#+BEGIN_SRC shell
  name[subscript]=value
  declare -a nameo
  declare -a name[subscript]
  name=(value1 value2 … )
#+END_SRC

#+BEGIN_SRC shell
  $ array=(one two three)

  $ echo "${array[@]}"
  one two three

  $ echo "$array[@]"
  one[@]

  $ echo "${array[2]}"
  three

  $ array[3]=four

  $ echo "${array[@]}"
  one two three four
#+END_SRC

- ~${name[*]}~ vs ~${name[@]}~
- [[#-vs-][$* vs $@]]

*** case
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html

#+BEGIN_SRC shell
  case "$1" in
    start)
      start
      ;;
    stop)
      stop
      ;;
    ,*)
      echo $"Usage: $0 {start|stop}"
      exit 1
      ;;
  esac
#+END_SRC

*** for
- https://www.cyberciti.biz/faq/bash-for-loop/
- https://google.github.io/styleguide/shell.xml?showone=Loops#Loops


- Put ~; do~ and ~; then~ on the same line as the ~while~, ~for~ or ~if~.
- Use a for loop if you are confident that the input will not contain spaces or special characters (usually, this means not user input).

#+BEGIN_SRC shell
  for i in 1 2 3 4 5; do
    echo "$i"
  done

  for file in ~/repos/* ; do
    echo "$file"
  done

  # continue and break
  for i in 1 2 3; do
    if [[ "$i" == 1 ]]; then
      continue
    fi
    if [[ "$i" == 3 ]]; then
      break
    fi
    echo "$i"
  done

  for (( i=1; i<=5; i++)); do
    echo "$i"
  done
#+END_SRC

#+BEGIN_SRC shell
  # requires bash v3.0+
  for i in {1..5}; do
    echo "$i"
  done

  # requires bash v4.0+
  for i in {0..10..2}; do
    echo "$i"
  done
#+END_SRC

*** function
- http://tldp.org/LDP/abs/html/functions.html
- http://tldp.org/LDP/abs/html/complexfunct.html
- http://ryanstutorials.net/bash-scripting-tutorial/bash-functions.php
- https://google.github.io/styleguide/shell.xml?showone=Function_Comments#Function_Comments
- http://stackoverflow.com/questions/18042279/how-to-exit-a-function-in-bash


#+BEGIN_SRC shell
  print_something() {
      echo Hello $1
  }
  print_something Mars
  print_something Jupiter
#+END_SRC

- The keyword ~function~ is *optional*, but must be used consistently throughout a project.
- If you're writing a package, separate package names with ~::~.

#+BEGIN_SRC shell
  # Single function
  my_func() {
      ...
  }

  # Part of a package
  mypackage::my_func() {
      ...
  }
#+END_SRC

#+BEGIN_SRC shell
  #######################################
  # Cleanup files from the backup dir
  # Globals:
  #   BACKUP_DIR
  #   ORACLE_SID
  # Arguments:
  #   None
  # Returns:
  #   None
  #######################################
  cleanup() {
      ...
  }
#+END_SRC

#+BEGIN_SRC shell
  # If N is omitted, the return status is that of the
  # last command executed within the function or script.
  return [n]
#+END_SRC

#+BEGIN_QUOTE
Note that if you have ~set -e~ set at the top of your script and
your ~return 1~ or any other number besides ~0~, your entire script will exit.
~exit~ abandons the current shell.
#+END_QUOTE

- By *default a variable is global.*
- When we create a local variable within a function, *it is only visible* within that function.
#+BEGIN_SRC shell
  var_change () {
      local var1='local 1'
      echo Inside function: var1 is $var1 : var2 is $var2
      var1='changed again'
      var2='2 changed again'
  }
  var1='global 1'
  var2='global 2'
  # only var2 changed
#+END_SRC

#+BEGIN_SRC shell
  foo() {
    return 0 # return returns a value from a function.
  }
  bar() {
    exit 1 # exit abandons the current shell.
  }

  foo
  echo 'hi'
  bar
  echo 'bye' # NOT printed
#+END_SRC

*** if
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html

#+BEGIN_SRC shell
  if commands; then
    commands
  [elif commands; then
    commands ...]
  [else
    commands]
  fi
#+END_SRC

The ~TEST-COMMAND~ list is executed, and if its return status is ~zero~,
the ~CONSEQUENT-COMMANDS~ list is executed.

[[file:img/screenshot_2017-04-24_12-19-35.png]]

[[file:img/screenshot_2017-04-24_12-10-01.png]]

#+BEGIN_SRC shell
  if [[ -z "$foo" ]] && [[ -z "$bar" ]];
  if [[ -z "$foo" && -z "$bar" ]]; # equivalent to above
#+END_SRC

**** [[, [ and test
- http://mywiki.wooledge.org/BashFAQ/031
- ~[~ and ~test~ are available in POSIX shells
- ~[[~ works only in Bash, Zsh and the Korn shell, and is more powerful
- ~[[~ is preferred over ~[~, ~test~ (from [[https://google.github.io/styleguide/shell.xml][Google Shell Style Guide]])

[[file:img/screenshot_2017-04-24_12-12-29.png]]

- Special primitives that ~[[~ is defined to have, but ~[~ may be lacking

** Syntax
*** Arithmetic Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Arithmetic-Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic

#+BEGIN_SRC shell
  $(( expression ))
#+END_SRC

*** Brace Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Brace-Expansion
- Performed before any other expansions
- Any characters special to other expansions are preserved in the result

#+BEGIN_SRC shell
  $ echo a{d,c,b}e
  ade ace abe

  $ mkdir /usr/local/src/bash/{old,new,dist,bugs}
  $ chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
#+END_SRC

*** Escaping quotes
**** Escaping double quotes
- Escape it with backslash

#+BEGIN_EXAMPLE
  "\""
#+END_EXAMPLE

- Double quoted shell expansion is valid within double quotes

#+BEGIN_SRC shell
  $ echo 'echo $#' > arg-count
  $ chmod +x arg-count
  $ ./arg-count
  0
  $ echo "$(./arg-count $(echo foo bar))"
  2
  $ echo "$(./arg-count "$(echo foo bar)")"
  1
#+END_SRC

**** Escaping single quotes within a single quoted string
- https://stackoverflow.com/questions/1250079/how-to-escape-single-quotes-within-single-quoted-strings

#+BEGIN_EXAMPLE
   alias rxvt='urxvt -fg '"'"'#111111'"'"' -bg '"'"'#111111'"'"
   #                     ^^^^^       ^^^^^     ^^^^^       ^^^^
   #                     12345       12345     12345       1234

#+END_EXAMPLE
1. ' End first quotation which uses single quotes.
2. " Start second quotation, using double-quotes.
3. ' Quoted character.
4. " End second quotation, using double-quotes.
5. ' Start third quotation, using single quotes.

Or, use ANSI C string:(~$''~). We can escape a single quote with =\'=.
But in this way, we loses bash's literal meaning. Other meta character like =\n=, =\t= will also get a special meaning.
#+BEGIN_SRC shell
  echo $'Can\'t do that'
#+END_SRC

*** Here document
- https://en.wikipedia.org/wiki/Here_document

#+BEGIN_SRC shell
  tr a-z A-Z << END_TEXT
  one two three
  four five six
  END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  ONE TWO THREE
  FOUR FIVE SIX
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Ignore leading tabs
  tr a-z A-Z <<- END_TEXT
           one two three
           four five six
           END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  (Same as above)
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Disable string interpolation
  cat << 'EOF'
  \$ Working dir "$PWD" `pwd`
  EOF
#+END_SRC
#+BEGIN_EXAMPLE
  \$ Working dir "$PWD" `pwd`
#+END_EXAMPLE


- For redirections and pipelining:
- https://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat

#+BEGIN_SRC shell
  cat <<EOF | sh
  touch somefile
  echo foo > somefile
  EOF
#+END_SRC

#+BEGIN_SRC shell
  (
  cat <<EOF
  touch somefile
  echo foo > somefile
  EOF
  ) | sh
#+END_SRC

#+BEGIN_SRC shell
  {
  cat <<EOF
  touch somefile
  echo foo > somefile
  EOF
  } | sh
#+END_SRC

#+BEGIN_SRC shell
  cat >out <<EOF
  test
  EOF
#+END_SRC

*** History Expansion
- http://www.thegeekstuff.com/2011/08/bash-history-expansion

#+BEGIN_SRC shell
  $ history
  1 tar cvf etc.tar /etc/
  2 cp /etc/passwd /backup
  3 ps -ef | grep http
  4 service sshd restart
  5 /usr/local/apache2/bin/apachectl restart

  $ !4  # 4
  service sshd restart

  $ !-2  # 2 commands back
  service sshd restart

  $ !!   # last (1 command back)
  $ !-1

  $ !ps  # command that starts with 'ps'
  ps -ef | grep http

  $ !?apache  # command that contains 'apache'
  /usr/local/apache2/bin/apachectl restart


  $ ls /etc/cron.daily/logrotate

  $ ^ls^cat^  # replace 'ls' with 'cat'
  cat /etc/cron.daily/logrotate

  $ cp /etc/passwd /backup

  $ ls -l !cp:^  # first argument
  ls -l /etc/passwd

  $ cp /etc/passwd /backup

  $ ls -l !cp:$  # last argument
  ls -l /backup

  $ ls -l !!:$  # last argument of last command
  $ ls -l !$    # equivalent to above

  $ ls -l !!:2  # second
  $ ls -l !!:*  # all

  $ !!:s/ls -l/cat/  # substitution

  $ cp /etc/password /backup/password.bak
  $ !!:gs/password/passwd/  # global substitution
  cp /etc/passwd /backup/passwd.bak

  $ ls -l !!:$:p  # print without executing it
#+END_SRC

*** Process Substitution
- https://www.gnu.org/software/bash/manual/bashref.html#Process-Substitution
- http://tldp.org/LDP/abs/html/process-sub.html
- https://en.wikipedia.org/wiki/Process_substitution

- ~<(command)~ ::
  Runs command and make its output appear as a file.

#+BEGIN_SRC shell
  $ diff <(sort file1) <(sort file2)
#+END_SRC

- ~>(command)~ ::
  Captures output that would normally go to a file, and redirect it to the input of a process.

#+BEGIN_SRC shell
  $ cat foo | tee >(tr '[:lower:]' '[:upper:]')
  hello, world  #    stdout of tee (original output)
  HELLO, WORLD  # file part of tee (process substitution)
#+END_SRC

*** Redirection
- http://tldp.org/LDP/abs/html/io-redirection.html

#+BEGIN_SRC shell
  $ : > foo.txt  # truncate
  $ > foo.txt    # same as above, but some shells don't support

  $ echo 'hi' > foo.txt   # stdout
  $ echo 'hi' >> foo.txt  # stdout, append

  # fd 1 is stdout; same as above
  $ echo 'hi' 1> foo.txt
  $ echo 'hi' 1>> foo.txt

  # fd 2 is stderr (following commands will cause errors)
  $ tar 2> foo.txt
  $ cp 2>> foo.txt

  $ tar &> foo.txt  # both

  # redirects stderr to stdout
  # (M>&N redirects file descriptor M to file descriptor N, M is 1 if omitted)
  $ tar > out.txt 2>&1

  # multiple redirections
  $ command < input-file > output-file
#+END_SRC

#+BEGIN_SRC shell
  # '[j]<>filename'
  # Open file "filename" for reading and writing, and assign file descriptor "j" to it.
  # 'n<&-' Close input file descriptor n.
  # '0<&-', '<&-', Close stdin
  $ echo 1234567890 > File    # Write string to "File".
  $ exec 3<> File             # Open "File" and assign fd 3 to it.
  $ read -n 4 <&3             # Read only 4 characters.
  $ echo -n . >&3             # Write a decimal point there.
  $ exec 3>&-                 # Close fd 3.
  $ cat File                  # ==> 1234.67890
  #  Random access, by golly.
#+END_SRC

*** Shebang
- https://stackoverflow.com/questions/10376206/what-is-the-preferred-bash-shebang/10383546#10383546
- Use ~#!/usr/bin/env bash~ for portability ::
  *Different *nixes* put ~bash~ in different places, and using ~/usr/bin/env~ is a workaround to run the *first bash found on the PATH*.

*** Shell Parameter Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion

**** unset and null testing expansions  
- [[unset-null-examples.sh]]

- ~${parameter:-word}~ ::
#+BEGIN_EXAMPLE
  if not parameter:
    word
  else:
    parameter
#+END_EXAMPLE

- ~${parameter:=word}~ ::
#+BEGIN_EXAMPLE
  if not parameter:
    parameter = word
    parameter
#+END_EXAMPLE

- ~${parameter:?word}~ ::
#+BEGIN_EXAMPLE
  if not parameter:
    stderr.write(word)
    exit
  else:
    parameter
#+END_EXAMPLE

- ~${parameter:+word}~ ::
#+BEGIN_EXAMPLE
  if not parameter:
    parameter 
  else:
    word
#+END_EXAMPLE

- non ~:~ versions like ~${parameter-word}~ ::
  Tests only whether ~parameter~ is ~unset~, but not ~null~

- ~word~ ::
  Can be a variable like ~$(parameter:-$foo}~

#+BEGIN_SRC shell
  unset FOO
  echo ${FOO-bar}   # bar
  echo ${FOO?bar}   # (cause an error)
  echo ${FOO+bar}   # (unset value of FOO)
  echo ${FOO:-bar}  # bar
  echo ${FOO:?bar}  # (cause an error)
  echo ${FOO:+bar}  # (unset value of FOO)
  unset FOO
  echo ${FOO=bar}   # bar
  echo ${FOO}       # bar
  unset FOO
  echo ${FOO:=bar}  # bar
  echo ${FOO}       # bar


  FOO=
  echo ${FOO-bar}   # (null value of FOO)
  echo ${FOO?bar}   # (null value of FOO)
  echo ${FOO+bar}   # bar
  echo ${FOO:-bar}  # bar
  echo ${FOO:?bar}  # (cause an error)
  echo ${FOO:+bar}  # (null value of FOO)
  FOO=
  echo ${FOO=bar}   # (null value of FOO)
  echo ${FOO}       # (null value of FOO)
  FOO=
  echo ${FOO:=bar}  # bar
  echo ${FOO}       # bar


  FOO=foo
  echo ${FOO-bar}   # foo
  echo ${FOO?bar}   # foo
  echo ${FOO+bar}   # bar
  echo ${FOO:-bar}  # foo
  echo ${FOO:?bar}  # foo
  echo ${FOO:+bar}  # bar
  FOO=foo
  echo ${FOO=bar}   # foo
  echo ${FOO}       # foo
  FOO=foo
  echo ${FOO:=bar}  # foo
  echo ${FOO}       # foo
#+END_SRC

**** Others
#+BEGIN_SRC shell
  #!/usr/bin/env bash

  echo 'FOO is unset'
  printf '%-11s %s %s\n' '${FOO-bar}' '# ' "${FOO-bar}"
  printf '%-11s %s %s\n' '${FOO:-bar}' '# ' "${FOO:-bar}"

  echo
  echo 'FOO='
  FOO=
  printf '%-11s %s %s\n' '${FOO-bar}' '# ' "(empty string of FOO)"
  printf '%-11s %s %s\n' '${FOO:-bar}' '# ' "${FOO:-bar}"

  echo
  echo 'FOO=foo'
  FOO=foo
  printf '%-11s %s %s\n' '${FOO-bar}' '# ' "${FOO-bar}"
  printf '%-11s %s %s\n' '${FOO:-bar}' '# ' "${FOO:-bar}"
#+END_SRC

#+BEGIN_SRC shell
  ${parameter:offset}        # parameter[offset:]
  ${parameter:offset:length} # parameter[offset:offset+length]
#+END_SRC

#+BEGIN_SRC shell :outputs
  # ${parameter/pattern/string}
  #   longest match of pattern, If pattern begins with ‘/’, matches all
  export FOO='a.b.c.d'
  echo "${FOO/[.]/-}"
  echo "${FOO//[.]/-}"
#+END_SRC

#+BEGIN_EXAMPLE
  | a-b.c.d |
  | a-b-c-d |
#+END_EXAMPLE

* Topics
** Pseudo Terminals
- https://www.quora.com/What-is-the-purpose-of-a-pseudo-tty

if you run a process on the terminal,
you can interrupt it by pressing ~Ctrl+C~.

if a process is not associated with any terminal,
you *can't* interrupt it with ~Ctrl+C~,
instead you would probably have to run ~kill~ or something like that

~sshd~ process *passes your keystrokes to the remote process*
by writing them to the master end of the *pseudo-terminal*.

By default the remote ~sshd~ will allocate a ~pty~ only *when you don't specify* a command.

If you try ~ssh remote.host screen~ then
you'll see that specifying the command suppresses the ~pty~ allocation and you'll be in trouble again.
To avoid this, specify the ~-t~ option, and then the remote ~sshd~ will always try to allocate a terminal.

Use the flag of ~-T~ for explicitly disabling ~pty~.

* How-to
** Change hostname
#+BEGIN_SRC shell
  sudo sed -i "s/^127.0.0.1 localhost.*\$/127.0.0.1 localhost ${NEW_NAME}/" /etc/hosts
  sudo bash -c "echo ${NEW_NAME} > /etc/hostname"
  sudo hostname "${NEW_NAME}"
#+END_SRC

** Empty the contents of a file
- https://unix.stackexchange.com/questions/88808/empty-the-contents-of-a-file

#+BEGIN_SRC shell
  > filename                   # clever
  cp /dev/null filename        # naive
  cat /dev/null > filename     # intuitive
  dd if=/dev/null of=filename  # efficient
  truncate filename --size 0   # explicit
#+END_SRC

** Force exit code 0 in spite of error
- https://unix.stackexchange.com/questions/118217/chmod-silent-mode-how-force-exit-code-0-in-spite-of-error

#+BEGIN_SRC shell
  set -euo pipefail
  <command> || true
  echo 'Prints even if <command> fails'
#+END_SRC

** Get the source directory
- http://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
- https://stackoverflow.com/questions/35006457/choosing-between-0-and-bash-source

#+BEGIN_SRC shell
  DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#+END_SRC

~${BASH_SOURCE[0]}~ can also be used when the script is sourced, where ~$0~ can't be used.
Repalce ~BASH_SOURCE~ with ~$0~ for zsh, taking account of the [[http://stackoverflow.com/questions/35006457/choosing-between-0-and-bash-source][limitation]].

** Glob dotfiles
- http://stackoverflow.com/questions/20895502/bash-asterisk-omits-files-that-start-with
- http://unix.stackexchange.com/questions/89749/cp-hidden-files-with-glob-patterns

You can't just match dotfiles(whose names start with ~.~) with the wildcard(~*~).
There are some workarounds:
#+BEGIN_SRC shell
  for item in .* *; do echo "$item"; done  # simplest

  # for bash (shopt is bash specific)
  shopt -s dotglob  # set dotglob
  echo *
  shopt -u dotglob  # unset dotglob

  # for zsh (glob qualifier, GLOB_DOTS)
  $ cp foo/*(D) .
#+END_SRC

** Pipe stderr, and not stdout?
- https://stackoverflow.com/questions/2342826/how-to-pipe-stderr-and-not-stdout
- Redirect ~stderr~ to ~stdout~
- Redirect ~stdout~ to ~/dev/null~

#+BEGIN_SRC shell
  command 2>&1 >/dev/null | grep 'something'
#+END_SRC

** Prevent partially downloaded scripts from executing
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  {
      # Your code here
  }
#+END_SRC

** Prompt a user for yes/no
- http://stackoverflow.com/questions/3231804/in-bash-how-to-add-are-you-sure-y-n-to-any-command-or-alias/3231821#3231821
- http://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script

#+BEGIN_SRC shell
  read -p "Are you sure you want to continue? <y/N> " prompt
  if [[ "$prompt" =~ [yY](es)* ]]; then
  fi
#+END_SRC

** Run python simple web server for sharing files
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  python -m SimpleHTTPServer 7777
  python3 -m http.server 7777
#+END_SRC

** Temporarily move to a different working directory via subshell
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  # do something in current dir
  (cd /some/other/dir && other-command)
  # continue in original dir
#+END_SRC

** Trim a variable
- https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
- See also [[#shell-parameter-expansion][Shell Parameter Expansion]]

#+BEGIN_SRC shell
  trim() {
    local s="$1"
    # Remove leading whitespace characters
    s="${s#"${s%%[![:space:]]*}"}"
    # Remove trailing whitespace characters
    s="${s%"${s##*[![:space:]]}"}"
    echo -n "$s"
    #     └─ do not print the trailing newline character
  }
#+END_SRC

** Use command output as a file
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  diff /etc/hosts <(ssh somehost cat /etc/hosts)
#+END_SRC

** Useful One-liners
- https://github.com/jlevy/the-art-of-command-line#one-liners

#+BEGIN_SRC shell
  cat a b | sort | uniq > c        # c is a union b
  cat a b | sort | uniq -d > c     # c is a intersect b
  cat a b b | sort | uniq -u > c   # c is set difference a - b

  grep . *     # overview for contents of current directory
  head -100 *  # same as above, with only first 100 lines

  # sum of all numbers in the third column
  awk '{ x += $3 } END { print x }' myfile
#+END_SRC

** Wait until a port available
- https://unix.stackexchange.com/questions/5277/how-do-i-tell-a-script-to-wait-for-a-process-to-start-accepting-requests-on-a-po

#+BEGIN_SRC shell
  # Wait until 3306 port available
  while ! nc -z localhost 3306; do sleep 3; done
#+END_SRC

* Links
- https://github.com/jlevy/the-art-of-command-line
- https://google.github.io/styleguide/shell.xml
- https://github.com/progrium/bashstyle
- https://github.com/bahamas10/bash-style-guide
- https://github.com/alebcay/awesome-shell
- http://www.commandlinefu.com/
- https://github.com/alrra/dotfiles

* Staging
** TODO <2017-06-29 Thu> shift
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html

** TODO <2017-02-09 Thu> How do I copy multiple files by wildcard?
http://unix.stackexchange.com/questions/122605/how-do-i-copy-multiple-files-by-wildcard

** TODO <2017-02-01 Wed> cron.d
- http://askubuntu.com/questions/56683/where-is-the-cron-crontab-log

** TODO <2017-02-01 Wed> Device Naming on Linux Instances
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html

** TODO <2017-03-01 Wed> command command
- http://askubuntu.com/questions/512770/what-is-use-of-command-command
- http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/677212#677212

** TODO <2017-03-01 Wed> Detect ostype
- http://stackoverflow.com/questions/394230/detect-the-os-from-a-bash-script

** TODO <2017-03-30 Thu> trap
http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html
This instructs the trap command to catch the listed SIGNALS, which may be signal names with or without the SIG prefix, or signal numbers. If a signal is 0 or EXIT, the COMMANDS are executed when the shell exits. If one of the signals is DEBUG, the list of COMMANDS is executed after every simple command. A signal may also be specified as ERR;
- trap 'rm "$TERRAFORM_PLAN"' EXIT

** TODO <2017-07-02 Sun> Bash curly braces in variables
- https://stackoverflow.com/questions/8748831/when-do-we-need-curly-braces-in-variables-using-bash
- https://google.github.io/styleguide/shell.xml#Variable_expansion

** TODO <2017-07-03 Mon> here-document to variables
- https://stackoverflow.com/questions/1167746/how-to-assign-a-heredoc-value-to-a-variable-in-bash
- https://unix.stackexchange.com/questions/265149/why-is-set-o-errexit-breaking-this-read-heredoc-expression/265151#265151
- https://unix.stackexchange.com/questions/68419/how-to-print-in-here-document
  
** TODO <2017-07-03 Mon> "cat -"

** TODO <2017-07-03 Mon> IFS?

** TODO <2017-07-03 Mon> HERE_STRINGS
** TODO <2017-07-03 Mon> wc -l
- https://stackoverflow.com/questions/6314679/in-bash-how-do-i-count-the-number-of-lines-in-a-variable

** TODO <2017-07-03 Mon> source in function
- https://unix.stackexchange.com/questions/151889/why-does-bashs-source-command-behave-differently-when-called-from-a-function
** eval vs source
- https://unix.stackexchange.com/questions/123063/what-is-the-difference-between-eval-and-source-dev-stdin

** addpath
- https://unix.stackexchange.com/questions/217622/add-path-to-path-if-not-already-in-path
#+BEGIN_SRC shell
  addpath() {
    if [[ ":${PATH}:" != *":$1:"* ]]; then
      PATH="$1:${PATH}"
    fi
  }

#+END_SRC
** if content exists multiline string
- https://stackoverflow.com/questions/21128592/bash-text-search-find-if-the-content-of-one-file-exists-in-another-file

** echo "${string1#"$string2"}"
- https://stackoverflow.com/questions/25725391/bash-path-difference-between-two-paths

** bash grouping commands
- https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html

** capturing multiline output
- https://stackoverflow.com/questions/613572/capturing-multiple-line-output-into-a-bash-variable

** bash source return
- https://stackoverflow.com/questions/9640660/any-way-to-exit-bash-script-but-not-quitting-the-terminal

** sudo keep alive
- https://gist.github.com/cowboy/3118588

** GNU locale categories
- https://www.gnu.org/savannah-checkouts/gnu/libc/manual/html_node/Locale-Categories.html
- https://stackoverflow.com/questions/30479607/explain-the-effects-of-export-lang-lc-ctype-lc-all

** set -e not exit in function
- https://stackoverflow.com/questions/25794905/why-does-set-e-true-false-true-not-exit
- https://stackoverflow.com/questions/19789102/why-is-bash-errexit-not-behaving-as-expected-in-function-calls

** bash check variable exists
- https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash

** shell initialization
- https://github.com/rbenv/rbenv/wiki/Unix-shell-initialization

** check if a program exists
- https://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script

** check if two paths are equal in Bash
- https://stackoverflow.com/questions/33980224/how-to-check-if-two-paths-are-equal-in-bash

** Delete all broken symbolic links with a line
- https://stackoverflow.com/questions/22097130/delete-all-broken-symbolic-links-with-a-line

** determine current shell
- https://stackoverflow.com/questions/3327013/how-to-determine-the-current-shell-im-working-on

** hash -r
#+BEGIN_SRC shell
  # ----------------------------------------------------------------------------
  # For bash and zhs,  hash command must be called to forget past commands.
  # Without forgetting past commands, $PATH changes may not take effect.
  if [[ "${BASH-}" || "${ZSH_VERSION-}" ]]; then
    hash -r 2>/dev/null
    #     └─ forget all previously remembered utility locations
  fi
  # ----------------------------------------------------------------------------
#+END_SRC
** negative offset of shell parameter expansion
#+BEGIN_SRC shell

  if [[ "${file: -3}" == ".tf" ]]; then
    #           └─  a negative offset must be separated from the colon by
    #               at least one space to avoid being confused with :- expansion
#+END_SRC

** empty array and [@]
- https://stackoverflow.com/questions/7577052/bash-empty-array-expansion-with-set-u
