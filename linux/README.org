#+TITLE: Linux

* Table of Contents :TOC_2_gh:
- [[#overview][Overview]]
- [[#reference][Reference]]
  - [[#du][du]]
  - [[#lsof][lsof]]
  - [[#mount][mount]]
  - [[#pgrep][pgrep]]
  - [[#pkill][pkill]]
  - [[#su][su]]
  - [[#iostat][iostat]]
  - [[#top][top]]
- [[#terminology][Terminology]]
- [[#topics][Topics]]
  - [[#inode-structure][Inode Structure]]
  - [[#numa][NUMA]]
- [[#how-to][How-to]]
  - [[#config-swap-spacesfiles][Config swap spaces/files]]
  - [[#mount-a-volume][Mount a Volume]]
- [[#staging][Staging]]
  - [[#2017-07-16-sun-sudo-service---status-all][<2017-07-16 Sun> sudo service --status-all]]
  - [[#2017-07-13-thu-linux-kernel-parameters][<2017-07-13 Thu> Linux kernel parameters]]
  - [[#2017-07-14-fri-linux-usergroup][<2017-07-14 Fri> linux user/group]]
  - [[#2017-03-24-fri-resolvconf][<2017-03-24 Fri> resolvconf]]
  - [[#read-free-command][Read 'free' command]]
  - [[#where-in--should-extra-disks-be-mounted][Where in “/” should extra disks be mounted?]]
  - [[#diskcache][diskcache]]

* Overview
- http://www.brendangregg.com/linuxperf.html

[[file:img/screenshot_2017-08-16_20-34-39.png]]
* Reference
** du
#+BEGIN_SRC shell
  $ du
  0       ./temp
  24      .

  $ du ./temp
  0       ./temp

  # -a stands for 'all files'
  $ du -a  ./
  8       ./404.html
  8       ./CNAME
  8       ./index.html
  0       ./temp/a
  0       ./temp/b
  0       ./temp
  24      .

  # -h stands for 'human readable'
  $ du -h
  0B    ./temp
  12K    .

  # list file in order of size
  $ du -a ./ | sort -n

  # merge subdirectories
  $ du -sh
  12K    .

  # display sizes of all entries in current directory
  $ du -sh *
  4.0K    404.html
  4.0K    CNAME
  4.0K    index.html
  0B    temp
#+END_SRC

** lsof
- https://itsmetommy.com/2011/06/23/lsof-list-of-open-files/

#+BEGIN_SRC shell
  lsof         # files opened by processes
  lsof -i      # opened internet sockets
  lsof -i :80  # opened internet sockets on port 80
  lsof -i udp
  lsof -i tcp
  lsof -i tcp:80
  lsof -p 4455 # opend by pid 4455

  sudo lsof /usr/sbin/httpd  # opened by httpd
  sudo lsof "$(which httpd)"

  # by pattern
  lsof -c h
  lsof -c httpd
  lsof -c Dropbox
  lsof | grep httpd
  lsof -c bash

  # by user
  lsof -u tommy
  lsof -u _www
  lsof -u root

  $ lsof -n -P # numeric ip(-n) and port(-P)
#+END_SRC

** mount
- http://unix.stackexchange.com/questions/91960/can-anyone-explain-the-output-of-mount

#+BEGIN_SRC shell
  $ sudo mount
  /dev/sda2 on / type ext4 (rw)
  proc on /proc type proc (rw)
  sysfs on /sys type sysfs (rw)
  devpts on /dev/pts type devpts (rw,gid=5,mode=620)
  tmpfs on /dev/shm type tmpfs (rw)
  /dev/sda1 on /boot type ext4 (rw)
  /dev/sda3 on /home type ext4 (rw)
  none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
  sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
  gvfs-fuse-daemon on /root/.gvfs type fuse.gvfs-fuse-daemon (rw,nosuid,nodev)

  $ sudo mount -a  # using informations on /etc/fstab
#+END_SRC

: <spec> on <file> type <vfstype> (<mntopts>)

| ~spec~    | the block device or remote filesystem to be mounted. |
| ~file~    | he mount point for the filesystem.                   |
| ~vfstype~ | the type of the filesystem.                          |
| ~mntopts~ | the mount options associated with the filesystem.    |

** pgrep
- https://www.poftut.com/pgrep-pkill-command-tutorial-examples-linux/

#+BEGIN_SRC shell
  pgrep pytho
  pgrep -u root ssh  # root user's ssh
  pgrep -f script.py # match against full arugment lists
  pgrep -l pytho     # Print pids along with their process names
  pgrep -x python    # requires exact match, substr is default
#+END_SRC

#+BEGIN_SRC shell
  $ pgrep nginx
  2165
  2166

  $ pgrep nginx -l
  2165 nginx
  2166 nginx

  $ pgrep nginx -a
  2165 nginx: master process nginx
  2166 nginx: worker process
#+END_SRC

** pkill
- Same as ~pgrep~, but kills matching processes

#+BEGIN_SRC shell
  pkill -9 pytho     # You can also specify singal
#+END_SRC

** su
- http://www.linfo.org/su.html

#+BEGIN_SRC shell
  # if <user> is not specified, 'root' is used;
  sudo su
  sudo su root  # same as above

  # Use switch to another user
  sudo su yeonghoey

  # With '-', su moves to target user's home directory,
  # along with his environment variables
  sudo su -
  sudo su - yeonghoey

  # run a command as a user
  sudo su -c 'ls /usr' root
#+END_SRC

** iostat
- https://forums.aws.amazon.com/thread.jspa?messageID=124044#124227
- https://unix.stackexchange.com/questions/104192/iostat-await-vs-svctm
- https://www.percona.com/blog/2014/06/25/why-util-number-from-iostat-is-meaningless-for-mysql-capacity-planning/

#+BEGIN_SRC shell
  iostat -xmdz 1
  #       ││││ └─ repeat every 1 second
  #       │││└─ omit output for any devices for which there was no activity during the sample period
  #       ││└─ display the device utilization report
  #       │└─ display statistics in megabytes per second
  #       └─ display extended statistics
#+END_SRC

#+BEGIN_EXAMPLE
  Device:  rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
  xvdf       0.00  2934.00    0.00 2000.00     0.00    48.69    49.86     2.59    1.30    0.00    1.30   0.50  99.60
#+END_EXAMPLE

- ~rrqm/s~, ~wrqm/s~  :: read/write requests merged per second

- ~r/s~, ~w/s~, ~rMB/s~, ~wMB/s~ :: reads/writes (throughput) per second

- ~avgrq-sz~ :: Average request size in *sectors* (512 bytes)
  In general if this number is below 16 (16 * 512 bytes = 8KB).
  If this number is low (<50), you are going to be IOPS limited.
  If it's high (>100), you are likely to be bandwidth limited.

- ~avgqu-sz~ :: Average queue size.
  Indicates how many requests are queued waiting to be serviced.
  If ~avgqu-sz~ gets big (*>30*), your application is submitting more requests per secondthan the volume can handle.

- ~await~ :: Average wait in *milliseconds*.
  The average amount of time the requests that were completed during this period waited
  from when they entered the queue to when they were serviced. 
  This number is a combination of the queue length and the average service time.

- ~svctm~ :: Service time in *milliseconds*.
  While ~await~ counts the whole wait time of requests, ~svctm~ counts only the time consumed by device.
  As Linux doesn't measure the actual service time, so ~svctm~ is just approximation.
  *Consider await more importantly.*

- ~%util~ ::
  Percentage of CPU time during whchi I/O requests were issed to the device. 
  High ~%util~ doesn't always say that there is an overload.
  If the device serves requests in parallel, this value can constantly be high.

** top
- [[top.org]] 

* Terminology
* Topics
** Inode Structure
- http://unix.stackexchange.com/questions/4402/what-is-a-superblock-inode-dentry-and-a-file

[[file:img/screenshot_2017-03-02_22-48-52.png]]

#+BEGIN_QUOTE
inodes starts at number 2 (root)

inode12(dir_1)’s count is 2, because it’s parent and self-reference(.) pointing it.
root(2) is only exception(expected 3 but 4), *because it’s pointed by superblock*;

The *superblock* is essentially file system metadata and defines the file system type, size, status, and
information about other metadata structures (metadata of metadata).
#+END_QUOTE

#+BEGIN_SRC shell
  $ ls -i
  624402 Applications   638157 Dropbox        606644 Pictures     19695291 nltk_data
  606600 Desktop        606588 Library      19316918 PredictionIO  2688212 repos
  606584 Documents      606640 Movies         606646 Public       24277126 screenshots
  606586 Downloads      606642 Music        24707402 bin          22461472 venvs
#+END_SRC

#+BEGIN_SRC shell
  $ touch test
  $ stat test
  File: 'test'
  Size: 0               Blocks: 0          IO Block: 4096   regular empty file
  Device: ca01h/51713d    Inode: 14999       Links: 1
  Access: (0664/-rw-rw-r--)  Uid: (  500/ec2-user)   Gid: (  500/ec2-user)
  Access: 2017-03-02 18:20:00.503961613 +0000
  Modify: 2017-03-02 18:20:00.503961613 +0000
  Change: 2017-03-02 18:20:00.503961613 +0000
  Birth: -
#+END_SRC
** NUMA
- https://en.wikipedia.org/wiki/Non-uniform_memory_access

Non-uniform memory access.

#+BEGIN_QUOTE
A system can starve several processors at the same time,
notably because only one processor can access the computer's memory at a time.(...)
NUMA attempts to address this problem by providing separate memory for each processor,
avoiding the performance hit when several processors attempt to address the same memory.
#+END_QUOTE

[[file:img/screenshot_2017-08-20_01-26-42.png]]

* How-to
** Config swap spaces/files
#+BEGIN_SRC shell
  [root]$ mkswap /dev/hdb1
  [root]$ swapon /dev/hdb1
#+END_SRC

#+BEGIN_SRC shell
  [root]$ dd if=/dev/zero of=/swap_file bs=1024k count=num_mb
  [root]$ mkswap /swap_file
  [root]$ swapon /swap_file
#+END_SRC

#+BEGIN_SRC shell
  [root]$ swapoff -a  # turns off all swap spaces
  [root]$ rm -f /swap_file
#+END_SRC

** Mount a Volume
- http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html
- https://en.wikipedia.org/wiki/Fstab

#+BEGIN_SRC shell
  # view your available disk devices and their mount points
  [root]$ lsblk
  NAME  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
  xvdf  202:80   0  100G  0 disk
  xvda1 202:1    0    8G  0 disk /

  # check other details
  [root]$ blkid
  /dev/xvda1: LABEL="/" UUID="abcdefgh-1234-ijkl-4567-qwertyasdfgh" TYPE="ext4" PARTLABEL="Linux" PARTUUID="12321555-asda-asas-asdg-142khkhkhcsd"
#+END_SRC

#+BEGIN_SRC shell
  [root]$ file -s /dev/xvda1
  /dev/xvda1: Linux rev 1.0 ext4 filesystem data, UUID=1701d228-e1bd-4094-a14c-8c64d6819362, ...

  [root]$ file -s /dev/xvdf
  /dev/xvdf: data  # no file system
#+END_SRC

#+BEGIN_SRC shell
  [root]$ mkfs -t ext4 /dev/xvdf
  [root]$ mkdir /my/path
  [root]$ mount /dev/xvdf /my/path
#+END_SRC

#+BEGIN_SRC shell
  # Mount the volume permanently
  [root]$ cp /etc/fstab /etc/fstab.orig  # backup

  # /etc/fstab : columns are separated with ' ' or '\t'
  # ------------------------------------------------------------------------------
  # Use UUID because /dev/xvdf may change
  # - check UUID from the output of file -s /dev/xvdf
  # SEE: $ man fstab
  # - 0 stands for (not dumping, default)
  # - 2 stands for (other than root volume)
  /dev/xvda1  (...)
  UUID=de9a1ccd-a2dd-44f1-8be8-2d4275cb85a3  /my/path  ext4  defaults,nofail  0  2
  # ------------------------------------------------------------------------------

  # mount with /etc/fstab manually
  [root]$ mount -a
#+END_SRC

*** lost+found
- http://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix

#+BEGIN_QUOTE
The thing is, the file had a name and location once, but that information is no longer available.
So ~fsck~ deposits the file in a specific directory, called ~lost+found~
#+END_QUOTE

#+BEGIN_QUOTE
Files that appear in ~lost+found~ are typically files that were already unlinked (i.e. their name had been erased)
but still opened by some process (so the data wasn't erased yet)when the system halted suddenly (kernel panic or power failure).
If that's all that happened, these files were slated for deletion anyway, you don't need to care about them.
#+END_QUOTE

#+BEGIN_QUOTE
On many filesystems, the ~lost+found~ directory is a bit special
because it preallocates a bit of space for ~fsck~ to deposit files there. (...)
If you accidentally delete ~lost+found~, *don't re-create it with* ~mkdir~, *use* ~mklost+found~ *if available*.
#+END_QUOTE

* Staging
** TODO <2017-07-16 Sun> sudo service --status-all
- https://askubuntu.com/questions/407075/how-to-read-service-status-all-results

** TODO <2017-07-13 Thu> Linux kernel parameters
- http://meetup.toast.com/posts/54

** TODO <2017-07-14 Fri> linux user/group
- https://www.linode.com/docs/tools-reference/linux-users-and-groups
- https://stackoverflow.com/questions/14059916/is-there-a-command-to-list-all-unix-group-names

** TODO <2017-03-24 Fri> resolvconf
- http://askubuntu.com/questions/157154/how-do-i-include-lines-in-resolv-conf-that-wont-get-lost-on-reboot
- sudo vim /etc/resolvconf/resolv.conf.d/head --> ~nameserver 10.43.0.1~

** Read 'free' command
- http://www.linuxnix.com/find-ram-size-in-linuxunix/

** Where in “/” should extra disks be mounted?
- https://unix.stackexchange.com/questions/29134/where-in-should-extra-disks-be-mounted

** diskcache
- http://www.linuxatemyram.com/play.html

