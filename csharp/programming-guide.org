#+TITLE: C# Programming Guide

* Table of Contents :TOC_1_gh:
 - [[#inside-a-c-program][Inside a C# Program]]
 - [[#types][Types]]
 - [[#classes-and-structs][Classes and Structs]]

* Inside a C# Program
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/inside-a-program/

** Main Method:
#+BEGIN_SRC csharp
  static void Main()
  {
      //...
  }
  static int Main()
  {
      //...
      return 0;
  }
  static void Main(string[] args)
  {
      //...
  }
  static int Main(string[] args)
  {
      //...
      return 0;
  }
#+END_SRC

** General Structure of a C# Program
#+BEGIN_SRC csharp
  // A skeleton of a C# program 
  using System;
  namespace YourNamespace
  {
      class YourClass
      {
      }

      struct YourStruct
      {
      }

      interface IYourInterface 
      {
      }

      delegate int YourDelegate();

      enum YourEnum 
      {
      }

      namespace YourNestedNamespace
      {
          struct YourStruct 
          {
          }
      }

      class YourMainClass
      {
          static void Main(string[] args) 
          {
              //Your program starts here...
          }
      }
  }
#+END_SRC

** C# Coding Conventions
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/inside-a-program/coding-conventions

#+BEGIN_SRC csharp
  var currentPerformanceCounterCategory = new System.Diagnostics.
      PerformanceCounterCategory();

  // Use the + operator to concatenate short strings, as shown in the following code.
  string displayName = nameList[n].LastName + ", " + nameList[n].FirstName;

  // To append strings in loops, especially when you are working with large amounts of text, use a StringBuilder object.
  var phrase = "lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala";
  var manyPhrases = new StringBuilder();
  for (var i = 0; i < 10000; i++)
   {
       manyPhrases.Append(phrase);
  }


  // Use implicit typing for local variables when the type of the variable is obvious from the right side of the assignment,
  // or when the precise type is not important.
  var var1 = "This is clearly a string.";
  var var2 = 27;
  var var3 = Convert.ToInt32(Console.ReadLine());


  // Preferred syntax. Note that you cannot use var here instead of string[].
  string[] vowels1 = { "a", "e", "i", "o", "u" };
  // If you use explicit instantiation, you can use var.
  var vowels2 = new string[] { "a", "e", "i", "o", "u" };
  // If you specify an array size, you must initialize the elements one at a time.
  var vowels3 = new string[5];
  vowels3[0] = "a";
  vowels3[1] = "e";


  // This try-finally statement only calls Dispose in the finally block.
  Font font1 = new Font("Arial", 10.0f);
  try
  {
       byte charset = font1.GdiCharSet;
  }
  finally
  {
       if (font1 != null)
       {
           ((IDisposable)font1).Dispose();
       }
  }
  // You can do the same thing with a using statement.
  using (Font font2 = new Font("Arial", 10.0f))
  {
       byte charset = font2.GdiCharSet;
  }


  Console.Write("Enter a dividend: ");
  var dividend = Convert.ToInt32(Console.ReadLine());
  Console.Write("Enter a divisor: ");
  var divisor = Convert.ToInt32(Console.ReadLine());
  // If the divisor is 0, the second clause in the following condition
  // causes a run-time error. The && operator short circuits when the
  // first expression is false. That is, it does not evaluate the
  // second expression. The & operator evaluates both, and causes 
  // a run-time error when divisor is 0.
  if ((divisor != 0) && (dividend / divisor > 0))
   {
       Console.WriteLine("Quotient: {0}", dividend / divisor);
   }
   else
   {
       Console.WriteLine("Attempted division by 0 ends up here.");
  }


  // Call static members by using the class name: ClassName.StaticMember.
  // This practice makes code more readable by making static access clear.
  // Do not qualify a static member defined in a base class with the name of a derived class.
  // While that code compiles, the code readability is misleading, and the code may break in the future
  // if you add a static member with the same name to the derived class.
#+END_SRC
* Types
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/reference-tables-for-types
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/struct
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/class
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/interface
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/enum
[[file:img/screenshot_2017-05-06_11-00-02.png]]

- There are two categories of value types: ~struct~ and ~enum~.
- Assigning one value type variable to another *copies the contained value*.
- Unlike with reference types, you *cannot derive a new type from a value type*.
- However, like reference types, ~structs~ can implement interfaces.
- A type that is defined as a ~class~, ~delegate~, ~array~, or ~interface~ is a reference type.

* Classes and Structs
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/
- Classes are used to model more complex behavior, or data that is intended to be modified after a class object is created.
- Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created.
