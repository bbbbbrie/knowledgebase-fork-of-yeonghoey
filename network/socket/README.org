#+TITLE: Socket

* Table of Contents :TOC_3_gh:
- [[#overview][Overview]]
- [[#reference][Reference]]
- [[#terminology][Terminology]]
- [[#topics][Topics]]
  - [[#handling-eintr][Handling EINTR]]
- [[#how-to][How-to]]
- [[#links][Links]]
- [[#staging][Staging]]
  - [[#2017-08-23-wed-so_reuseaddr][<2017-08-23 Wed> SO_REUSEADDR]]

* Overview
* Reference
* Terminology
* Topics
** Handling EINTR
- http://250bpm.com/blog:12
- https://stackoverflow.com/questions/4959524/when-to-check-for-eintr-and-repeat-the-function-call

- POSIX specification defines that when signal (such as ~Ctrl+C~) is caught, ~recv~ returns ~EINTR~ error.
- When ~Ctrl+C~ is pressed in this case,
  1. signal handler is executed, 'stop' is set to 1,
  2. ~recv~ returns ~EINTR~
- Using ~SA_RESTART~ within the signal handler, it's possible to make the functions not return ~EINTR~ and just retry.

#+BEGIN_SRC c
  volatile int stop = 0;

  void handler (int)
  {
    stop = 1;
  }

  void event_loop (int sock)
  {
    signal (SIGINT, handler);

    while (1) {
      if (stop) {
        printf ("do cleanup\n");
        return;
      }

      /* What if signal handler is executed at this point?
         This may be a problem, or not. 
       */

      char buf [1];
      int rc = recv (sock, buf, 1, 0);
      if (rc == -1 && errno == EINTR)
        continue;
      printf ("perform an action\n");
    }
  }
#+END_SRC

* How-to
* Links
* Staging
** TODO <2017-08-23 Wed> SO_REUSEADDR
- https://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t
