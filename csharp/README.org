#+TITLE: C#

* Table of Contents :TOC_2_gh:
 - [[#c-concepts][C# Concepts]]
 - [[#c-net-and-mono][C#, .Net and Mono]]
 - [[#references][References]]
   - [[#accessibility-levels][Accessibility Levels]]
   - [[#array][Array]]
   - [[#arraylist][ArrayList]]
   - [[#as][as]]
   - [[#const][const]]
   - [[#listt][List<T>]]
   - [[#null][null]]
   - [[#nullablet][Nullable<T>]]
   - [[#properties][Properties]]
   - [[#readonly][readonly]]
   - [[#static-class-and-static-class-members][Static Class and Static Class Members]]
   - [[#tostring][ToString]]
 - [[#details][Details]]
   - [[#abstract-virtual-override-sealed][abstract, virtual, override, sealed]]
 - [[#use-cases][Use Cases]]
   - [[#can-i-make-local-vairalbes-constant][Can I make local vairalbes constant?]]
   - [[#can-i-handle-inputs-in-fixedupdate][Can I handle inputs in FixedUpdate?]]
   - [[#increment-operator-post-vs-pre][Increment operator: Post vs Pre?]]
   - [[#gaussian-random][Gaussian Random]]

* C# Concepts
- https://docs.microsoft.com/en-us/dotnet/articles/csharp/concepts

* C#, .Net and Mono
- https://en.wikipedia.org/wiki/C_Sharp_(programming_language)
- http://www.mono-project.com/docs/about-mono/compatibility/

[[file:img/screenshot_2017-05-02_22-07-04.png]]

* References
** Accessibility Levels
- https://msdn.microsoft.com/en-us/library/ba0a1yw2.aspx

[[file:img/screenshot_2017-05-03_11-10-34.png]]

[[file:img/screenshot_2017-05-03_11-12-35.png]]

** Array
- http://csharp.net-informations.com/collection/csharp-array.htm

#+BEGIN_SRC csharp
  int[] array = new int[] {10, 20, 30, 40};
  for (int i = 0; i < array.Length; i++)
  {
      MessageBox.Show (array[i]);
  }

  Array.Resize(ref array, 3);

  foreach (int element in array)
  {
      Console.WriteLine(element);
  }
#+END_SRC

** ArrayList
- http://stackoverflow.com/questions/2309694/arraylist-vs-list-in-c-sharp
- ~ArrayList~ simply stores object references.
- ~ArrayList~ belongs to the days that C# didn't have generics. It's deprecated in favor of ~List<T>~

** as
- https://msdn.microsoft.com/en-us/library/cscsdfbt.aspx
- if the conversion isn't possible, ~as~ returns null instead of raising an exception.

#+BEGIN_SRC csharp
  class ClassA { }
  class ClassB { }

  class MainClass
  {
      static void Main()
      {
          object[] objArray = new object[6];
          objArray[0] = new ClassA();
          objArray[1] = new ClassB();
          objArray[2] = "hello";
          objArray[3] = 123;
          objArray[4] = 123.4;
          objArray[5] = null;

          for (int i = 0; i < objArray.Length; ++i)
          {
              string s = objArray[i] as string;
              Console.Write("{0}:", i);
              if (s != null)
              {
                  Console.WriteLine("'" + s + "'");
              }
              else
              {
                  Console.WriteLine("not a string");
              }
          }
      }
  }
  /*
    Output:
    0:not a string
    1:not a string
    2:'hello'
    3:not a string
    4:not a string
    5:not a string
  ,*/
#+END_SRC

** const
- https://msdn.microsoft.com/en-us/library/e6w8fe1b.aspx
- The initializer of a constant local or a constant field must be
  a constant expression that can be implicitly converted to the target type
- A constant expression is an expression that *can be fully evaluated at compile time*

** List<T>
- https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx
- http://csharp.net-informations.com/collection/list.htm

#+BEGIN_SRC csharp
  List<string> colors = new List<string>();
  colors.Add("Red");
  colors.Add("Blue");
  colors.Add("Green");

  colors.Count;


  foreach (string color in colors)
  {
      MessageBox.Show(color);
  }

  for (int i = 0; i < colors.Count; i++)
  {
      MessageBox.Show(colors[i]);
  }

  colors.Insert(1, "violet");
  colors.Sort();
  colors.Remove("violet");


  if (colors.Contains("Blue"))
  {
      MessageBox.Show("Blue color exist in the list");
  }

  string[] strArr = new string[3];
  strArr[0] = "Red";
  strArr[1] = "Blue";
  strArr[2] = "Green";
  //here to copy array to List
  List<string> arrlist = new List<string>(strArr);

  string combindedString = string.Join(",", colors);

  string[] arr = colors.ToArray();

  arrlist.Clear ();
#+END_SRC

** null
- https://msdn.microsoft.com/en-us/library/dn986595.aspx

#+BEGIN_SRC csharp
  // Traditional null check
  var handler = this.PropertyChanged;
  if (handler != null)
      handler(â€¦)

  // equivalent to, and thread-safe thanks to compiler
  PropertyChanged?.Invoke(e)
#+END_SRC

#+BEGIN_SRC csharp
  int? length = customers?.Length; // null if customers is null
  Customer first = customers?[0];  // null if customers is null
  int? count = customers?[0]?.Orders?.Count();  // null if customers, the first customer, or Orders is null
#+END_SRC

#+BEGIN_SRC csharp
  // The ?? operator is called the null-coalescing operator.
  // It returns the left-hand operand if the operand is not null;
  // otherwise it returns the right hand operand.

  int? x = null;
  // Set y to the value of x if x is NOT null; otherwise,
  // if x = null, set y to -1.
  int y = x ?? -1;
#+END_SRC

** Nullable<T>
- https://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx
- The syntax ~T?~ is shorthand for ~Nullable<T>~,
  where ~T~ is a value type. The two forms are interchangeable.

** Properties
- https://msdn.microsoft.com/en-us/library/w86s7x04.aspx
- https://msdn.microsoft.com/en-us/library/bb384054.aspx
- ~set~ accessor resembles a method whose return type is ~void~.
  It uses an implicit parameter called ~value~

#+BEGIN_SRC csharp
  public class Date
  {
      private int month = 7;  // Backing store

      public int Month
      {
          get
          {
              return month;
          }
          set
          {
              if ((value > 0) && (value < 13))
              {
                  month = value;
              }
          }
      }
    }
#+END_SRC

#+BEGIN_SRC csharp
  // From C# 3.0
  // Auto-Impl Properties for trivial get and set
  public double TotalPurchases { get; set; }
  public string Name { get; set; }
  public int CustomerID { get; set; }

  // From C# 6.0
  public string FirstName { get; set; } = "Jane";
#+END_SRC

** readonly
- https://msdn.microsoft.com/en-us/library/acdd6hb7.aspx
- A ~const~ field can only be initialized at the declaration of the field.
- A ~readonly~ field can be initialized either at the declaration or in a constructor

- readonly *only works on class level*
Also as a consequence of const requiring a literal,
it's inherently static while a readonly field can be either static or instance.

#+BEGIN_SRC csharp
  class Age
  {
      readonly int _year;
      Age(int year)
      {
          _year = year;
      }

      void ChangeYear()
      {
          //_year = 1967; // Compile error if uncommented.
      }
    }
#+END_SRC

** Static Class and Static Class Members
- https://msdn.microsoft.com/en-us/library/79b3xss3.aspx
- https://msdn.microsoft.com/en-us/library/k9x6w0hc.aspx
- http://stackoverflow.com/questions/3681055/is-the-order-of-static-class-initialization-in-c-sharp-deterministic
- C# does not support static local variables
- Static members are initialized
  - before the static member is accessed for the first time
  - before the static constructor, if there is one, is called

#+BEGIN_SRC csharp
  public class Automobile
  {
      public static int NumberOfWheels = 4;
      public static int SizeOfGasTank
      {
          get
          {
              return 15;
          }
      }
      public static void Drive() { }
      public static event EventType RunOutOfGas;

      // Other non-static fields and properties...
  }
#+END_SRC

#+BEGIN_SRC csharp
  class SimpleClass
  {
      // Static variable that must be initialized at run time.
      static readonly long baseline;

      // Static constructor is called at most one time, before any
      // instance constructor is invoked or member is accessed.
      static SimpleClass()
      {
          baseline = DateTime.Now.Ticks;
      }
    }
#+END_SRC

** ToString
- https://msdn.microsoft.com/en-us/library/dwhawy9k.aspx

#+BEGIN_SRC csharp
  float score = 100.12345;
  Debug.Log(score.ToString("F2"));  # Fixed point, prints "100.12"
#+END_SRC

* Details
** abstract, virtual, override, sealed
- https://msdn.microsoft.com/en-us/library/6tcf2h8w.aspx
- http://stackoverflow.com/questions/6162451/the-difference-between-virtual-override-new-and-sealed-override
- http://www.dotnetfunda.com/articles/show/2961/abstract-sealed-and-override-modifiers-in-csharp


- The ~abstract~ modifier indicates that the thing being modified has a missing or incomplete implementation.
- The ~virtual~ keyword is used to modify a method, property, indexer, or event declaration and allow for it to be overridden in a derived class.
- By default, methods are *non-virtual*. You *cannot override* a non-virtual method.
- The ~override~ modifier is required to extend or modify the ~abstract~ or ~virtual~ implementation of an inherited method, property, indexer, or event.
- You can use ~sealed~ to prevent them from overriding specific ~virtual~ methods or properties. 

[[file:img/screenshot_2017-05-05_16-52-37.png]]


* Use Cases
** Can I make local vairalbes constant?
- http://stackoverflow.com/questions/2054761/how-to-declare-a-local-constant-in-c
-
In short, No. Because:

- ~const~ only for expressions can be evaluated at compile time
- ~readonly~ only works on class level
** Can I handle inputs in FixedUpdate?
- http://answers.unity3d.com/questions/620981/input-and-applying-physics-update-or-fixedupdate.html

*General Rule*:
- Input should be in ~Update~,
  so that there is no chance of having a frame in which you miss the player input
  (which could happen if you placed it in ~FixedUpdate~)
- Physics calculations should be in ~FixedUpdate~,
  so that they are consistent and synchronised with the global physics timestep of the game
  (by default 50 times per second)
- Camera movement should be in ~LateUpdate~,
  so that it reflects the positions of any objects that may have moved in the current frame

** Increment operator: Post vs Pre?
- http://stackoverflow.com/questions/467322/is-there-any-performance-difference-between-i-and-i-in-c
- The semantic is not different from C ++
- Thanks to the compiler, In short, *there will be no difference* in the runtime for control variables
** Gaussian Random
- https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform

#+BEGIN_SRC csharp
  // Boxâ€“Muller transform
  // https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
  public static float GaussianRandom(float mu, float sigma)
  {
		  float u1 = Random.Range(0.0f, 1.0f);
		  float u2 = Random.Range(0.0f, 1.0f);
		  float z0 = Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos((2.0f * Mathf.PI) * u2);
		  return (mu + sigma * z0);
	  }
#+END_SRC
