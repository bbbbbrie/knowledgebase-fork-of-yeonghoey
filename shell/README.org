#+TITLE: Shell

* Table of Contents                                                :TOC_2_gh:
- [[#reference][Reference]]
  - [[#-vs-][$* vs $@]]
  - [[#array][array]]
  - [[#case][case]]
  - [[#curl][curl]]
  - [[#date][date]]
  - [[#du][du]]
  - [[#for][for]]
  - [[#function][function]]
  - [[#grep][grep]]
  - [[#if][if]]
  - [[#jq][jq]]
  - [[#lsof][lsof]]
  - [[#mount][mount]]
  - [[#nc][nc]]
  - [[#pgrep][pgrep]]
  - [[#pkill][pkill]]
  - [[#set][set]]
  - [[#sort][sort]]
  - [[#su][su]]
  - [[#tar][tar]]
  - [[#tee][tee]]
  - [[#watch][watch]]
  - [[#xargs][xargs]]
  - [[#arithmetic-expansion][Arithmetic Expansion]]
  - [[#brace-expansion][Brace Expansion]]
  - [[#escaping-quotes][Escaping quotes]]
  - [[#here-document][Here document]]
  - [[#history-expansion][History Expansion]]
  - [[#redirection][Redirection]]
  - [[#shell-parameter-expansion][Shell Parameter Expansion]]
- [[#topics][Topics]]
  - [[#pseudo-terminals][Pseudo Terminals]]
- [[#how-to][How-to]]
  - [[#change-hostname][Change hostname]]
  - [[#empty-the-contents-of-a-file][Empty the contents of a file]]
  - [[#force-exit-code-0-in-spite-of-error][Force exit code 0 in spite of error]]
  - [[#get-the-source-directory][Get the source directory]]
  - [[#glob-dotfiles][Glob dotfiles]]
  - [[#pipe-stderr-and-not-stdout][Pipe stderr, and not stdout?]]
  - [[#prevent-partially-downloaded-scripts-from-executing][Prevent partially downloaded scripts from executing]]
  - [[#prompt-a-user-for-yesno][Prompt a user for yes/no]]
  - [[#run-python-simple-web-server-for-sharing-files][Run python simple web server for sharing files]]
  - [[#temporarily-move-to-a-different-working-directory-via-subshell][Temporarily move to a different working directory via subshell]]
  - [[#trim-a-variable][Trim a variable]]
  - [[#use-command-output-as-a-file][Use command output as a file]]
  - [[#useful-one-liners][Useful One-liners]]
- [[#links][Links]]
- [[#staging][Staging]]
  - [[#2017-06-29-thu-shift][<2017-06-29 Thu> shift]]
  - [[#2017-02-09-thu-how-do-i-copy-multiple-files-by-wildcard][<2017-02-09 Thu> How do I copy multiple files by wildcard?]]
  - [[#2017-02-09-thu-cat-xargs-grep][<2017-02-09 Thu> cat, xargs, grep]]
  - [[#2017-02-01-wed-crond][<2017-02-01 Wed> cron.d]]
  - [[#2017-02-01-wed-device-naming-on-linux-instances][<2017-02-01 Wed> Device Naming on Linux Instances]]
  - [[#2017-03-01-wed-command-command][<2017-03-01 Wed> command command]]
  - [[#2017-03-01-wed-detect-ostype][<2017-03-01 Wed> Detect ostype]]
  - [[#2017-03-02-thu-sed-separator][<2017-03-02 Thu> sed separator]]
  - [[#2017-03-23-thu-bash-escape-color][<2017-03-23 Thu> bash escape color]]
  - [[#2017-03-24-fri-resolvconf][<2017-03-24 Fri> resolvconf]]
  - [[#2017-03-30-thu-trap][<2017-03-30 Thu> trap]]

* Reference
** $* vs $@
- http://stackoverflow.com/questions/12314451/accessing-bash-command-line-args-vs
- https://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters
- Use ~​"$@"​~ for most cases

#+BEGIN_SRC shell
  $ set -- "arg  1" "arg  2" "arg  3"

  $ for word in $*; do echo "$word"; done
  arg
  1
  arg
  2
  arg
  3

  $ for word in $@; do echo "$word"; done
  arg
  1
  arg
  2
  arg
  3

  $ for word in "$*"; do echo "$word"; done
  arg  1 arg  2 arg  3

  $ for word in "$@"; do echo "$word"; done
  arg  1
  arg  2
  arg  3
#+END_SRC
** array
- https://www.gnu.org/software/bash/manual/bashref.html#Arrays
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_02.html

#+BEGIN_SRC shell
  name[subscript]=value
  declare -a nameo
  declare -a name[subscript]
  name=(value1 value2 … )
#+END_SRC

#+BEGIN_SRC shell
  $ array=(one two three)

  $ echo "${array[@]}"
  one two three

  $ echo "$array[@]"
  one[@]

  $ echo "${array[2]}"
  three

  $ array[3]=four

  $ echo "${array[@]}"
  one two three four
#+END_SRC

- ~${name[*]}~ vs ~${name[@]}~
- [[#-vs-][$* vs $@]]

** case
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html

#+BEGIN_SRC shell
  case "$1" in
    start)
      start
      ;;
    stop)
      stop
      ;;
    ,*)
      echo $"Usage: $0 {start|stop}"
      exit 1
      ;;
  esac
#+END_SRC

** curl
- https://ec.haxx.se/usingcurl-returns.html

#+BEGIN_SRC shell
  # return exit code 22 when url not found or
  # HTTP error code being 400 or above
  curl --fail <url>
#+END_SRC

** date
- https://www.gnu.org/software/coreutils/manual/html_node/Options-for-date.html
- https://www.gnu.org/software/coreutils/manual/html_node/Examples-of-date.html

#+BEGIN_SRC shell
  date -u
  #     └─ --utc
  # Fri Aug 18 06:57:31 UTC 2017

  date -R
  #     └─ --rfc─2822
  # Fri, 18 Aug 2017 15:55:42 +0900

  date '+%Y%m%dT%H%M%S'
  # 20170818T144038

  TZ='America/Los_Angeles' date
  # Fri Aug 18 00:01:11 PDT 2017

  date -d '2days ago'
  #     └─ --date, display time described by STRING, not 'now'
  # Wed Aug 16 16:05:03 KST 2017

  date -d '2days ago' '+%Y%m%dT%H%M%S'
  # 20170816T160622

  date --iso-8601
  # 2017-08-18

  date --iso-8601=seconds
  #                    └─ also can be 'auto', 'hours', 'minutes', 'ns'
  # 2017-08-18T17:12:30+09:00

  date --utc --iso-8601=seconds
  # 2017-08-18T08:12:49+00:00
#+END_SRC

** du
#+BEGIN_SRC shell
  $ du
  0       ./temp
  24      .

  $ du ./temp
  0       ./temp

  # -a stands for 'all files'
  $ du -a  ./
  8       ./404.html
  8       ./CNAME
  8       ./index.html
  0       ./temp/a
  0       ./temp/b
  0       ./temp
  24      .

  # -h stands for 'human readable'
  $ du -h
  0B    ./temp
  12K    .

  # list file in order of size
  $ du -a ./ | sort -n

  # merge subdirectories
  $ du -sh
  12K    .

  # display sizes of all entries in current directory
  $ du -sh *
  4.0K    404.html
  4.0K    CNAME
  4.0K    index.html
  0B    temp
#+END_SRC

** for
- https://www.cyberciti.biz/faq/bash-for-loop/
- https://google.github.io/styleguide/shell.xml?showone=Loops#Loops


- Put ~; do~ and ~; then~ on the same line as the ~while~, ~for~ or ~if~.
- Use a for loop if you are confident that the input will not contain spaces or special characters (usually, this means not user input).

#+BEGIN_SRC shell
  for i in 1 2 3 4 5; do
    echo "$i"
  done

  for file in ~/repos/* ; do
    echo "$file"
  done

  # continue and break
  for i in 1 2 3; do
    if [[ "$i" == 1 ]]; then
      continue
    fi
    if [[ "$i" == 3 ]]; then
      break
    fi
    echo "$i"
  done

  for (( i=1; i<=5; i++)); do
    echo "$i"
  done
#+END_SRC

#+BEGIN_SRC shell
  # requires bash v3.0+
  for i in {1..5}; do
    echo "$i"
  done

  # requires bash v4.0+
  for i in {0..10..2}; do
    echo "$i"
  done
#+END_SRC

** function
- http://tldp.org/LDP/abs/html/functions.html
- http://tldp.org/LDP/abs/html/complexfunct.html
- http://ryanstutorials.net/bash-scripting-tutorial/bash-functions.php
- https://google.github.io/styleguide/shell.xml?showone=Function_Comments#Function_Comments
- http://stackoverflow.com/questions/18042279/how-to-exit-a-function-in-bash


#+BEGIN_SRC shell
  print_something() {
      echo Hello $1
  }
  print_something Mars
  print_something Jupiter
#+END_SRC

- The keyword ~function~ is *optional*, but must be used consistently throughout a project.
- If you're writing a package, separate package names with ~::~.

#+BEGIN_SRC shell
  # Single function
  my_func() {
      ...
  }

  # Part of a package
  mypackage::my_func() {
      ...
  }
#+END_SRC

#+BEGIN_SRC shell
  #######################################
  # Cleanup files from the backup dir
  # Globals:
  #   BACKUP_DIR
  #   ORACLE_SID
  # Arguments:
  #   None
  # Returns:
  #   None
  #######################################
  cleanup() {
      ...
  }
#+END_SRC

#+BEGIN_SRC shell
  # If N is omitted, the return status is that of the
  # last command executed within the function or script.
  return [n]
#+END_SRC

#+BEGIN_QUOTE
Note that if you have ~set -e~ set at the top of your script and
your ~return 1~ or any other number besides ~0~, your entire script will exit.
~exit~ abandons the current shell.
#+END_QUOTE

- By *default a variable is global.*
- When we create a local variable within a function, *it is only visible* within that function.
#+BEGIN_SRC shell
  var_change () {
      local var1='local 1'
      echo Inside function: var1 is $var1 : var2 is $var2
      var1='changed again'
      var2='2 changed again'
  }
  var1='global 1'
  var2='global 2'
  # only var2 changed
#+END_SRC

#+BEGIN_SRC shell
  foo() {
    return 0 # return returns a value from a function.
  }
  bar() {
    exit 1 # exit abandons the current shell.
  }

  foo
  echo 'hi'
  bar
  echo 'bye' # NOT printed
#+END_SRC

** grep
- https://www.gnu.org/software/grep/manual/grep.html#Usage

#+BEGIN_SRC shell
  $ tail *.txt
  ==> foo.txt <==
  foo
  FOO

  ==> foobar.txt <==
  foo
  bar
  foobar
#+END_SRC

#+BEGIN_SRC shell
  $ grep foo foo.txt
  foo

  $ grep -i foo foo.txt  # -i, --ignore-case
  foo
  FOO

  $ grep -n foo foobar.txt  # -n, --line-number
  1:foo
  3:foobar

  $ grep -o foo foobar.txt  # -o, --only-matching
  foo
  foo

  $ grep -v foo foobar.txt  # -v, --invert-match
  bar

  $ grep -l foo *  # -l, --files-with-matches
  foo.txt
  foobar.txt

  $ grep -H foo *  # -H, Always print filename headers
  foo.txt:foo
  foobar.txt:foo
  foobar.txt:foobar

  $ grep -r foo .  # -R, -r, --recursive, Prints filename headers by default
  ./foo.txt:foo
  ./foobar.txt:foo
  ./foobar.txt:foobar

  $ grep -rh foo .  # -h, --no-filename
  foo
  foo
  foobar

  $ grep -w foo foobar.txt  # -w, --word-regexp
  foo

  $ grep -C2 bar foobar.txt  # -C[num, --context=num], num=2 by default, See also -A(after), -B(before)
  foo
  bar
  foobar

  $ grep -F foo.* foobar.txt  # -F, --fixed-strings, literal match

  $ grep -q foo foo.txt; echo $?  # -q, --quiet, --silent
  0
  $ grep -q bar foo.txt; echo $?
  1

  $ grep -e '--foo' foo.txt  # -e [pattern], --regexp=pattern, Indicate following argument as regexp explicitly

  $ grep -Z foo foobar.tar.gz; echo $?  # -Z, -z, --decompress, Behave as zgrep
  Binary file foobar.tar.gz matches
  0
  $ grep -Z baz foobar.tar.gz; echo $?
  1
#+END_SRC

** if
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html

#+BEGIN_SRC shell
  if commands; then
    commands
  [elif commands; then
    commands ...]
  [else
    commands]
  fi
#+END_SRC

The ~TEST-COMMAND~ list is executed, and if its return status is ~zero~,
the ~CONSEQUENT-COMMANDS~ list is executed.

[[file:img/screenshot_2017-04-24_12-19-35.png]]

[[file:img/screenshot_2017-04-24_12-10-01.png]]

#+BEGIN_SRC shell
  if [[ -z "$foo" ]] && [[ -z "$bar" ]];
  if [[ -z "$foo" && -z "$bar" ]]; # equivalent to above
#+END_SRC

*** [[, [ and test
- http://mywiki.wooledge.org/BashFAQ/031
- ~[~ and ~test~ are available in POSIX shells
- ~[[~ works only in Bash, Zsh and the Korn shell, and is more powerful
- ~[[~ is preferred over ~[~, ~test~ (from [[https://google.github.io/styleguide/shell.xml][Google Shell Style Guide]])

[[file:img/screenshot_2017-04-24_12-12-29.png]]

- Special primitives that ~[[~ is defined to have, but ~[~ may be lacking

** jq
- https://stedolan.github.io/jq/manual/
- https://jqplay.org/

#+BEGIN_SRC json
  [{"name": "apple", "price": 10}, {"name": "orange", "price": 20}]
#+END_SRC

#+BEGIN_SRC shell
  jq '.[] | select(.["name"] | test("or.*")) | {(.["name"]): .["price"]}'
  #              │                │             │          └─ object construction
  #              │                │             └─ expression keys need to be parenthesized
  #              │                └─ regex match returns boolean
  #              └─ select values where conditional is true
#+END_SRC

#+BEGIN_SRC json
  {"orange": 20}
#+END_SRC

** lsof
- https://itsmetommy.com/2011/06/23/lsof-list-of-open-files/

#+BEGIN_SRC shell
  lsof         # files opened by processes
  lsof -i      # opened internet sockets
  lsof -i :80  # opened internet sockets on port 80
  lsof -i udp
  lsof -i tcp
  lsof -i tcp:80
  lsof -p 4455 # opend by pid 4455

  sudo lsof /usr/sbin/httpd  # opened by httpd
  sudo lsof "$(which httpd)"

  # by pattern
  lsof -c h
  lsof -c httpd
  lsof -c Dropbox
  lsof | grep httpd
  lsof -c bash

  # by user
  lsof -u tommy
  lsof -u _www
  lsof -u root

  $ lsof -n -P # numeric ip(-n) and port(-P)
#+END_SRC

** mount
- http://unix.stackexchange.com/questions/91960/can-anyone-explain-the-output-of-mount

#+BEGIN_SRC shell
  $ sudo mount
  /dev/sda2 on / type ext4 (rw)
  proc on /proc type proc (rw)
  sysfs on /sys type sysfs (rw)
  devpts on /dev/pts type devpts (rw,gid=5,mode=620)
  tmpfs on /dev/shm type tmpfs (rw)
  /dev/sda1 on /boot type ext4 (rw)
  /dev/sda3 on /home type ext4 (rw)
  none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
  sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
  gvfs-fuse-daemon on /root/.gvfs type fuse.gvfs-fuse-daemon (rw,nosuid,nodev)

  $ sudo mount -a  # using informations on /etc/fstab
#+END_SRC

: <spec> on <file> type <vfstype> (<mntopts>)

| ~spec~    | the block device or remote filesystem to be mounted. |
| ~file~    | he mount point for the filesystem.                   |
| ~vfstype~ | the type of the filesystem.                          |
| ~mntopts~ | the mount options associated with the filesystem.    |

** nc
- https://unix.stackexchange.com/questions/5277/how-do-i-tell-a-script-to-wait-for-a-process-to-start-accepting-requests-on-a-po

#+BEGIN_SRC shell
  # Wait until 3306 port available
  while ! nc -z localhost 3306; do sleep 3; done
#+END_SRC

** pgrep
- https://www.poftut.com/pgrep-pkill-command-tutorial-examples-linux/

#+BEGIN_SRC shell
  pgrep pytho
  pgrep -u root ssh  # root user's ssh
  pgrep -f script.py # match against full arugment lists
  pgrep -l pytho     # Print pids along with their process names
  pgrep -x python    # requires exact match, substr is default
#+END_SRC

#+BEGIN_SRC shell
  $ pgrep nginx
  2165
  2166

  $ pgrep nginx -l
  2165 nginx
  2166 nginx

  $ pgrep nginx -a
  2165 nginx: master process nginx
  2166 nginx: worker process
#+END_SRC

** pkill
- Same as ~pgrep~, but kills matching processes

#+BEGIN_SRC shell
  pkill -9 pytho     # You can also specify singal
#+END_SRC

** set
- https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html
- https://github.com/jlevy/the-art-of-command-line

#+BEGIN_SRC shell
  set -e # Exit immediately when a command fails
  set -x # Print a trace of simple commands

  set +x # Use + rather than -  to turn off.

  set -- 'foo' 'bar' # set the positional parameters
  echo "$1, $2"      # 'foo, bar'
#+END_SRC

#+BEGIN_SRC shell
  set -euo pipefail
  trap "echo 'error: Script failed: see failed command above'" ERR
#+END_SRC
- ~-e~ for errors
- ~-u~ for preventing unset
- ~-o pipefail~ for errors within pipes

*** set -x for a line
- http://stackoverflow.com/questions/13195655/bash-set-x-without-it-being-printed

#+BEGIN_SRC shell
  set -x
  command
  { set +x; } 2>/dev/null

  # or simply
  ( set -x; command )
#+END_SRC

** sort
- http://ss64.com/bash/sort.html
- http://www.skorks.com/2010/05/sort-files-like-a-master-with-the-linux-sort-command-bash/

#+BEGIN_SRC shell
  sort -nr numbers.txt # descending numeric order
  sort -k3 output.txt  # key3, omitting the first and second fields.
  sort -f names.txt    # ignore case
  sort -s names.txt    # stable sort
  sort -u names.txt    # unique
  sort -t: /etc/passwd # use ':' as the field delimiter
#+END_SRC

#+BEGIN_SRC shell
  # Sort by column2 and then column4, numerically, delimited by '.'
  # while -k2  only specifies starting point is column2
  # -k2,2  specifies both starting, and ending point. which means exact column2.

  $ cat ips.txt | sort -t. -k 2,2n -k 4,4n
  127.0.0.3
  127.0.0.6
  127.0.0.12
  192.168.0.1
  192.168.0.5
  192.168.0.25
#+END_SRC

** su
- http://www.linfo.org/su.html

#+BEGIN_SRC shell
  # if <user> is not specified, 'root' is used;
  sudo su
  sudo su root  # same as above

  # Use switch to another user
  sudo su yeonghoey

  # With '-', su moves to target user's home directory,
  # along with his environment variables
  sudo su -
  sudo su - yeonghoey

  # run a command as a user
  sudo su -c 'ls /usr' root
#+END_SRC

** tar
- http://www.tecmint.com/18-tar-command-examples-in-linux/
- http://askubuntu.com/questions/122141/whats-the-difference-between-tar-gz-and-gz-or-tar-7z-and-7z

| flag      | mnemonic         |
|-----------+------------------|
| ~-c~      | create           |
| ~-x~      | extract          |
| ~-t~      | list             |
| ~-v~      | verbose          |
| ~-z~      | gzip             |
| ~-C DIR~  | change directory |
| ~-f FILE~ | target file      |

-----
#+BEGIN_SRC shell
  $ cd /tmp
  $ tree target
#+END_SRC
#+BEGIN_EXAMPLE
  target
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -cvf target1.tar /tmp/target
#+END_SRC
#+BEGIN_EXAMPLE
  tar: Removing leading '/' from member names
  a tmp/target
  a tmp/target/a.txt
  a tmp/target/path
  a tmp/target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -xvf target1.tar
  $ tree tmp
#+END_SRC
#+BEGIN_EXAMPLE
  tmp
  └── target
      ├── a.txt
      └── path
          └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Change directory
  $ tar -C /tmp/target -cvf target2.tar .
#+END_SRC
#+BEGIN_EXAMPLE
  a .
  a ./a.txt
  a ./path
  a ./path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ mkdir out
  $ tar -C out -xvf target2.tar
  $ tree out
#+END_SRC
#+BEGIN_EXAMPLE
  out
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Exclude
  $ tar -cvf target3.tar --exclude a.txt target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
#+BEGIN_SRC shell
  # Compression
  $ tar -cvzf target.tar.gz target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/a.txt
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Don't need any option for extracting compressed tar
  $ tar -xvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  x target/
  x target/a.txt
  x target/path/
  x target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # List
  $ tar -tvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/a.txt
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/path/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Untar a single file
  $ tar -xvf target.tar.gz target/a.txt
#+END_SRC
#+BEGIN_EXAMPLE
  x target/a.txt
#+END_EXAMPLE

** tee
- https://shapeshed.com/unix-tee/

#+BEGIN_SRC shell
  $ echo 'foo' | tee foo.txt
  foo
  $ cat foo.txt
  foo
#+END_SRC

#+BEGIN_SRC shell
  $ cat foo.txt
  foo
  $ echo 'bar' | tee -a foo.txt  # append
  bar
  $ cat foo.txt
  foo
  bar
#+END_SRC

#+BEGIN_SRC shell
  # Redirecting stdout is not affected by 'sudo'
  $ echo 'foo' >> file
  zsh: permission denied: file

  # 'tee' can be used to work around this
  $ echo "foo" | sudo tee -a file
#+END_SRC

** watch
#+BEGIN_SRC shell
  watch ls        # run 'ls' every 2 seconds (default)
  watch -d ls     # highlight differences
  watch -n 60 ls  # every 60 seconds
#+END_SRC

** xargs
- http://www.thegeekstuff.com/2013/12/xargs-examples
- http://www.unixmantra.com/2013/12/xargs-all-in-one-tutorial-guide.html
- https://www.cyberciti.biz/faq/linux-unix-bsd-xargs-construct-argument-lists-utility/

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs echo

  # equivalent to:
  echo 1 2 3 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 1 echo

  # equivalent to:
  echo 1
  echo 2
  echo 3
  echo 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 2 echo

  # equivalent to:
  echo 1 2
  echo 3 4
#+END_SRC

#+BEGIN_SRC shell
  # Specify replace-str
  $ echo 1 2 3 4 | xargs -I {} echo '{} numbers'

  # equivalent to
  echo '1 2 3 4 numbers'
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -p echo   # Prompt
  $ echo 1,2,3,4 | xargs -d, echo  # Set delimiter to ','

  # Use null character as input terminator, useful when input contains white space.
  # For example, 'find -print0' supports this
  $ echo 1 2 3 4 | xargs -0 echo

  # Delete files whose names contain 'conflicted'
  $ find . -name '*conflicted*' -print0 | xargs -0 rm
#+END_SRC

** Arithmetic Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Arithmetic-Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic

#+BEGIN_SRC shell
  $(( expression ))
#+END_SRC

** Brace Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Brace-Expansion
- Performed before any other expansions
- Any characters special to other expansions are preserved in the result

#+BEGIN_SRC shell
  $ echo a{d,c,b}e
  ade ace abe

  $ mkdir /usr/local/src/bash/{old,new,dist,bugs}
  $ chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
#+END_SRC

** Escaping quotes
*** Escaping double quotes
- Escape it with backslash

#+BEGIN_EXAMPLE
  "\""
#+END_EXAMPLE

- Double quoted shell expansion is valid within double quotes

#+BEGIN_SRC shell
  $ echo 'echo $#' > arg-count
  $ chmod +x arg-count
  $ ./arg-count
  0
  $ echo "$(./arg-count $(echo foo bar))"
  2
  $ echo "$(./arg-count "$(echo foo bar)")"
  1
#+END_SRC

*** Escaping single quotes within a single quoted string
- https://stackoverflow.com/questions/1250079/how-to-escape-single-quotes-within-single-quoted-strings

#+BEGIN_EXAMPLE
   alias rxvt='urxvt -fg '"'"'#111111'"'"' -bg '"'"'#111111'"'"
   #                     ^^^^^       ^^^^^     ^^^^^       ^^^^
   #                     12345       12345     12345       1234

#+END_EXAMPLE
1. ' End first quotation which uses single quotes.
2. " Start second quotation, using double-quotes.
3. ' Quoted character.
4. " End second quotation, using double-quotes.
5. ' Start third quotation, using single quotes.

Or, use ANSI C string:(~$''~). We can escape a single quote with =\'=.
But in this way, we loses bash's literal meaning. Other meta character like =\n=, =\t= will also get a special meaning.
#+BEGIN_SRC shell
  echo $'Can\'t do that'
#+END_SRC

** Here document
- https://en.wikipedia.org/wiki/Here_document

#+BEGIN_SRC shell
  tr a-z A-Z << END_TEXT
  one two three
  four five six
  END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  ONE TWO THREE
  FOUR FIVE SIX
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Ignore leading tabs
  tr a-z A-Z <<- END_TEXT
           one two three
           four five six
           END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  (Same as above)
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Disable string interpolation
  cat << 'EOF'
  \$ Working dir "$PWD" `pwd`
  EOF
#+END_SRC
#+BEGIN_EXAMPLE
  \$ Working dir "$PWD" `pwd`
#+END_EXAMPLE


- For redirections and pipelining:
- https://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat

#+BEGIN_SRC shell
  cat <<EOF | sh
  touch somefile
  echo foo > somefile
  EOF
#+END_SRC

#+BEGIN_SRC shell
  (
  cat <<EOF
  touch somefile
  echo foo > somefile
  EOF
  ) | sh
#+END_SRC

#+BEGIN_SRC shell
  {
  cat <<EOF
  touch somefile
  echo foo > somefile
  EOF
  } | sh
#+END_SRC

#+BEGIN_SRC shell
  cat >out <<EOF
  test
  EOF
#+END_SRC

** History Expansion
- http://www.thegeekstuff.com/2011/08/bash-history-expansion

#+BEGIN_SRC shell
  $ history
  1 tar cvf etc.tar /etc/
  2 cp /etc/passwd /backup
  3 ps -ef | grep http
  4 service sshd restart
  5 /usr/local/apache2/bin/apachectl restart

  $ !4  # 4
  service sshd restart

  $ !-2  # 2 commands back
  service sshd restart

  $ !!   # last (1 command back)
  $ !-1

  $ !ps  # command that starts with 'ps'
  ps -ef | grep http

  $ !?apache  # command that contains 'apache'
  /usr/local/apache2/bin/apachectl restart


  $ ls /etc/cron.daily/logrotate

  $ ^ls^cat^  # replace 'ls' with 'cat'
  cat /etc/cron.daily/logrotate

  $ cp /etc/passwd /backup

  $ ls -l !cp:^  # first argument
  ls -l /etc/passwd

  $ cp /etc/passwd /backup

  $ ls -l !cp:$  # last argument
  ls -l /backup

  $ ls -l !!:$  # last argument of last command
  $ ls -l !$    # equivalent to above

  $ ls -l !!:2  # second
  $ ls -l !!:*  # all

  $ !!:s/ls -l/cat/  # substitution

  $ cp /etc/password /backup/password.bak
  $ !!:gs/password/passwd/  # global substitution
  cp /etc/passwd /backup/passwd.bak

  $ ls -l !!:$:p  # print without executing it
#+END_SRC

** Redirection
- http://tldp.org/LDP/abs/html/io-redirection.html

#+BEGIN_SRC shell
  $ : > foo.txt  # truncate
  $ > foo.txt    # same as above, but some shells don't support

  $ echo 'hi' > foo.txt   # stdout
  $ echo 'hi' >> foo.txt  # stdout, append

  # fd 1 is stdout; same as above
  $ echo 'hi' 1> foo.txt
  $ echo 'hi' 1>> foo.txt

  # fd 2 is stderr (following commands will cause errors)
  $ tar 2> foo.txt
  $ cp 2>> foo.txt

  $ tar &> foo.txt  # both

  # redirects stderr to stdout
  # (M>&N redirects file descriptor M to file descriptor N, M is 1 if omitted)
  $ tar > out.txt 2>&1

  # multiple redirections
  $ command < input-file > output-file
#+END_SRC

#+BEGIN_SRC shell
  # '[j]<>filename'
  # Open file "filename" for reading and writing, and assign file descriptor "j" to it.
  # 'n<&-' Close input file descriptor n.
  # '0<&-', '<&-', Close stdin
  $ echo 1234567890 > File    # Write string to "File".
  $ exec 3<> File             # Open "File" and assign fd 3 to it.
  $ read -n 4 <&3             # Read only 4 characters.
  $ echo -n . >&3             # Write a decimal point there.
  $ exec 3>&-                 # Close fd 3.
  $ cat File                  # ==> 1234.67890
  #  Random access, by golly.
#+END_SRC

** Shell Parameter Expansion
- https://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion

#+BEGIN_SRC shell
  ${parameter:-word} # parameter if parameter else word
  ${parameter:=word} # if not parameter: parameter = word; parameter
  ${parameter:?word} # if not parameter: stderr.write(word); exit; else: parameter
  ${parameter:+word} # if not parameter: '' else word
#+END_SRC

#+BEGIN_SRC shell
  ${parameter:offset}        # parameter[offset:]
  ${parameter:offset:length} # parameter[offset:offset+length]
#+END_SRC

#+BEGIN_SRC shell :outputs
  # ${parameter/pattern/string}
  #   longest match of pattern, If pattern begins with ‘/’, matches all
  export FOO='a.b.c.d'
  echo "${FOO/[.]/-}"
  echo "${FOO//[.]/-}"
#+END_SRC

#+RESULTS:
| a-b.c.d |
| a-b-c-d |

* Topics
** Pseudo Terminals
- https://www.quora.com/What-is-the-purpose-of-a-pseudo-tty

if you run a process on the terminal,
you can interrupt it by pressing ~Ctrl+C~.

if a process is not associated with any terminal,
you *can't* interrupt it with ~Ctrl+C~,
instead you would probably have to run ~kill~ or something like that

~sshd~ process *passes your keystrokes to the remote process*
by writing them to the master end of the *pseudo-terminal*.

By default the remote ~sshd~ will allocate a ~pty~ only *when you don't specify* a command.

If you try ~ssh remote.host screen~ then
you'll see that specifying the command suppresses the ~pty~ allocation and you'll be in trouble again.
To avoid this, specify the ~-t~ option, and then the remote ~sshd~ will always try to allocate a terminal.

Use the flag of ~-T~ for explicitly disabling ~pty~.

* How-to
** Change hostname
#+BEGIN_SRC shell
  sudo sed -i "s/^127.0.0.1 localhost.*\$/127.0.0.1 localhost ${NEW_NAME}/" /etc/hosts
  sudo bash -c "echo ${NEW_NAME} > /etc/hostname"
  sudo hostname "${NEW_NAME}"
#+END_SRC

** Empty the contents of a file
- https://unix.stackexchange.com/questions/88808/empty-the-contents-of-a-file

#+BEGIN_SRC shell
  > filename                   # clever
  cp /dev/null filename        # naive
  cat /dev/null > filename     # intuitive
  dd if=/dev/null of=filename  # efficient
  truncate filename --size 0   # explicit
#+END_SRC

** Force exit code 0 in spite of error
- https://unix.stackexchange.com/questions/118217/chmod-silent-mode-how-force-exit-code-0-in-spite-of-error

#+BEGIN_SRC shell
  set -euo pipefail
  <command> || true
  echo 'Prints even if <command> fails'
#+END_SRC

** Get the source directory
- http://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
- https://stackoverflow.com/questions/35006457/choosing-between-0-and-bash-source

#+BEGIN_SRC shell
  DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#+END_SRC

~${BASH_SOURCE[0]}~ can also be used when the script is sourced, where ~$0~ can't be used.
Repalce ~BASH_SOURCE~ with ~$0~ for zsh, taking account of the [[http://stackoverflow.com/questions/35006457/choosing-between-0-and-bash-source][limitation]].

** Glob dotfiles
- http://stackoverflow.com/questions/20895502/bash-asterisk-omits-files-that-start-with
- http://unix.stackexchange.com/questions/89749/cp-hidden-files-with-glob-patterns

You can't just match dotfiles(whose names start with ~.~) with the wildcard(~*~).
There are some workarounds:
#+BEGIN_SRC shell
  for item in .* *; do echo "$item"; done  # simplest

  # for bash (shopt is bash specific)
  shopt -s dotglob  # set dotglob
  echo *
  shopt -u dotglob  # unset dotglob

  # for zsh (glob qualifier, GLOB_DOTS)
  $ cp foo/*(D) .
#+END_SRC

** Pipe stderr, and not stdout?
- https://stackoverflow.com/questions/2342826/how-to-pipe-stderr-and-not-stdout
- Redirect ~stderr~ to ~stdout~
- Redirect ~stdout~ to ~/dev/null~

#+BEGIN_SRC shell
  command 2>&1 >/dev/null | grep 'something'
#+END_SRC

** Prevent partially downloaded scripts from executing
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  {
      # Your code here
  }
#+END_SRC

** Prompt a user for yes/no
- http://stackoverflow.com/questions/3231804/in-bash-how-to-add-are-you-sure-y-n-to-any-command-or-alias/3231821#3231821
- http://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script

#+BEGIN_SRC shell
  read -p "Are you sure you want to continue? <y/N> " prompt
  if [[ "$prompt" =~ [yY](es)* ]]; then
  fi
#+END_SRC

** Run python simple web server for sharing files
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  python -m SimpleHTTPServer 7777
  python3 -m http.server 7777
#+END_SRC

** Temporarily move to a different working directory via subshell
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  # do something in current dir
  (cd /some/other/dir && other-command)
  # continue in original dir
#+END_SRC

** Trim a variable
- https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
- See also [[#shell-parameter-expansion][Shell Parameter Expansion]]

#+BEGIN_SRC shell
  trim() {
    local s="$1"
    # Remove leading whitespace characters
    s="${s#"${s%%[![:space:]]*}"}"
    # Remove trailing whitespace characters
    s="${s%"${s##*[![:space:]]}"}"
    echo -n "$s"
    #     └─ do not print the trailing newline character
  }
#+END_SRC

** Use command output as a file
- https://github.com/jlevy/the-art-of-command-line#everyday-use

#+BEGIN_SRC shell
  diff /etc/hosts <(ssh somehost cat /etc/hosts)
#+END_SRC

** Useful One-liners
- https://github.com/jlevy/the-art-of-command-line#one-liners

#+BEGIN_SRC shell
  cat a b | sort | uniq > c        # c is a union b
  cat a b | sort | uniq -d > c     # c is a intersect b
  cat a b b | sort | uniq -u > c   # c is set difference a - b

  grep . *     # overview for contents of current directory
  head -100 *  # same as above, with only first 100 lines

  # sum of all numbers in the third column
  awk '{ x += $3 } END { print x }' myfile
#+END_SRC

* Links
- https://github.com/jlevy/the-art-of-command-line
- https://google.github.io/styleguide/shell.xml
- https://github.com/progrium/bashstyle
- https://github.com/bahamas10/bash-style-guide
- https://github.com/alebcay/awesome-shell

* Staging
** TODO <2017-06-29 Thu> shift
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html

** TODO <2017-02-09 Thu> How do I copy multiple files by wildcard?
http://unix.stackexchange.com/questions/122605/how-do-i-copy-multiple-files-by-wildcard

** TODO <2017-02-09 Thu> cat, xargs, grep
#+BEGIN_EXAMPLE
  cat names | xargs -I {} grep --exclude='*.po' '{}' k1server/**/*(.)
#+END_EXAMPLE

** TODO <2017-02-01 Wed> cron.d
- http://askubuntu.com/questions/56683/where-is-the-cron-crontab-log

** TODO <2017-02-01 Wed> Device Naming on Linux Instances
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html

** TODO <2017-03-01 Wed> command command
- http://askubuntu.com/questions/512770/what-is-use-of-command-command
- http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/677212#677212

** TODO <2017-03-01 Wed> Detect ostype
- http://stackoverflow.com/questions/394230/detect-the-os-from-a-bash-script

** TODO <2017-03-02 Thu> sed separator
- http://backreference.org/2010/02/20/using-different-delimiters-in-sed/

** TODO <2017-03-23 Thu> bash escape color
http://misc.flogisoft.com/bash/tip_colors_and_formatting

** TODO <2017-03-24 Fri> resolvconf
- http://askubuntu.com/questions/157154/how-do-i-include-lines-in-resolv-conf-that-wont-get-lost-on-reboot
- sudo vim /etc/resolvconf/resolv.conf.d/head --> ~nameserver 10.43.0.1~

** TODO <2017-03-30 Thu> trap
http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html
This instructs the trap command to catch the listed SIGNALS, which may be signal names with or without the SIG prefix, or signal numbers. If a signal is 0 or EXIT, the COMMANDS are executed when the shell exits. If one of the signals is DEBUG, the list of COMMANDS is executed after every simple command. A signal may also be specified as ERR;
